export const fullStackDeveloperQuestions = [
  // ===== EASY (30 questions) =====
  {
    questionText: "What is the difference between frontend and backend development?",
    idealAnswer: "Frontend handles the user interface — HTML, CSS, JavaScript running in the browser. Backend handles server-side logic — APIs, databases, authentication, business rules. Full-stack developers work on both, understanding how they connect via HTTP APIs. Frontend focuses on UX/rendering; backend focuses on data, security, and performance.",
    category: "General",
    difficulty: "EASY" as const,
    tags: ["full-stack", "frontend", "backend"],
  },
  {
    questionText: "What is the MVC pattern and how does it apply to web development?",
    idealAnswer: "MVC separates an application into Model (data/business logic), View (UI/presentation), and Controller (handles input, updates model, selects view). In web apps: Model = database/ORM layer, View = HTML/React templates, Controller = route handlers/API endpoints. This separation makes code maintainable, testable, and allows parallel development of each layer.",
    category: "Architecture",
    difficulty: "EASY" as const,
    tags: ["mvc", "architecture", "patterns"],
  },
  {
    questionText: "What is an API and what types exist?",
    idealAnswer: "An API (Application Programming Interface) defines how software components communicate. Types: REST (resource-based HTTP endpoints), GraphQL (query language, single endpoint), gRPC (binary protocol, protobuf), WebSocket (real-time bidirectional), SOAP (XML-based, legacy). REST is most common for web apps. APIs define contracts between frontend and backend.",
    category: "APIs",
    difficulty: "EASY" as const,
    tags: ["api", "rest", "graphql"],
  },
  {
    questionText: "Explain the HTTP request-response cycle.",
    idealAnswer: "Client sends an HTTP request with: method (GET/POST/etc), URL, headers, optional body. DNS resolves the domain to an IP. TCP connection established (TLS handshake for HTTPS). Server processes the request through middleware, routes to a handler, and returns a response with: status code, headers, body. The browser renders the response. Connection may be kept alive for subsequent requests.",
    category: "HTTP",
    difficulty: "EASY" as const,
    tags: ["http", "networking", "web"],
  },
  {
    questionText: "What is version control and why is Git important?",
    idealAnswer: "Version control tracks file changes over time, enabling collaboration, history tracking, and rollback. Git is a distributed VCS — every developer has a full repository copy. Key concepts: commits (snapshots), branches (parallel development), merging, pull requests for code review. Essential for teamwork, CI/CD pipelines, and maintaining code quality.",
    category: "Git",
    difficulty: "EASY" as const,
    tags: ["git", "version-control", "collaboration"],
  },
  {
    questionText: "What is a database schema and why is it important?",
    idealAnswer: "A schema defines the structure of a database: tables, columns, data types, relationships, and constraints. It ensures data integrity (NOT NULL, UNIQUE, foreign keys), documents the data model, and enables ORMs to generate type-safe queries. Changes are managed through migrations. A well-designed schema prevents data anomalies and supports efficient queries.",
    category: "Databases",
    difficulty: "EASY" as const,
    tags: ["databases", "schema", "prisma"],
  },
  {
    questionText: "What is the difference between cookies, localStorage, and sessionStorage?",
    idealAnswer: "Cookies: sent with every HTTP request, 4KB limit, have expiry, accessible server-side (Set-Cookie header) and client-side. localStorage: 5MB, persists indefinitely, client-only. sessionStorage: 5MB, clears when tab closes, client-only. Use cookies for auth tokens (httpOnly for security), localStorage for preferences, sessionStorage for temporary form data.",
    category: "Web APIs",
    difficulty: "EASY" as const,
    tags: ["cookies", "storage", "web-apis"],
  },
  {
    questionText: "What is HTTPS and why is it important?",
    idealAnswer: "HTTPS encrypts HTTP traffic using TLS (Transport Layer Security). It provides: confidentiality (data can't be read in transit), integrity (data can't be modified), authentication (server identity verified via certificates). Essential for: login forms, payment processing, any PII. Required for service workers, HTTP/2, and modern browser features. Use Let's Encrypt for free certificates.",
    category: "Security",
    difficulty: "EASY" as const,
    tags: ["https", "tls", "security"],
  },
  {
    questionText: "What is JSON and why is it the standard for APIs?",
    idealAnswer: "JSON (JavaScript Object Notation) is a lightweight text format for data interchange. It supports: strings, numbers, booleans, null, arrays, and objects. It's human-readable, language-agnostic, natively parsed in JavaScript, and compact. It replaced XML for most APIs due to simplicity. Used in REST APIs, configuration files, and data storage. Parse with `JSON.parse()`, serialize with `JSON.stringify()`.",
    category: "Data Formats",
    difficulty: "EASY" as const,
    tags: ["json", "api", "data-formats"],
  },
  {
    questionText: "What is npm and how does it relate to Node.js?",
    idealAnswer: "npm (Node Package Manager) is the default package manager for Node.js, hosting over 2 million packages. `package.json` defines project dependencies and scripts. `node_modules/` stores installed packages. `package-lock.json` locks exact versions for reproducible builds. Key commands: `npm install`, `npm run`, `npm publish`. Alternatives: yarn, pnpm (faster, disk-efficient).",
    category: "Tooling",
    difficulty: "EASY" as const,
    tags: ["npm", "nodejs", "tooling"],
  },
  {
    questionText: "What is responsive design and why does it matter?",
    idealAnswer: "Responsive design makes websites work across all screen sizes (mobile, tablet, desktop). Techniques: CSS media queries, flexible grids (Flexbox/Grid), fluid images, viewport meta tag. Mobile-first approach starts with small screens. Matters because over 50% of web traffic is mobile. Test with browser DevTools device mode. Frameworks like Tailwind CSS provide responsive utility classes.",
    category: "CSS",
    difficulty: "EASY" as const,
    tags: ["responsive", "css", "mobile"],
  },
  {
    questionText: "What is a RESTful API and what are its conventions?",
    idealAnswer: "REST uses HTTP methods for CRUD: GET (read), POST (create), PUT/PATCH (update), DELETE (remove). URLs represent resources as nouns: `/api/users`, `/api/users/:id`. Conventions: plural nouns, nested resources for relationships, proper status codes (200, 201, 404, etc.), stateless requests, consistent response format. Pagination, filtering, and sorting via query parameters.",
    category: "APIs",
    difficulty: "EASY" as const,
    tags: ["rest", "api", "http"],
  },
  {
    questionText: "What is a Single Page Application (SPA)?",
    idealAnswer: "A SPA loads a single HTML page and dynamically updates content using JavaScript without full page reloads. Routing is handled client-side. Benefits: faster navigation, app-like feel, reduced server load. Drawbacks: slow initial load, SEO challenges, JavaScript required. Frameworks: React, Vue, Angular. Modern approach: hybrid with SSR (Next.js) for best of both worlds.",
    category: "Architecture",
    difficulty: "EASY" as const,
    tags: ["spa", "architecture", "frontend"],
  },
  {
    questionText: "What are environment variables and how do you use them?",
    idealAnswer: "Environment variables store configuration that varies between environments — API URLs, database connections, API keys. They separate config from code and keep secrets out of version control. Use `.env` files with dotenv locally, platform-specific config in production (Docker, Vercel, Railway). Access via `process.env.VARIABLE_NAME` in Node.js. Never commit `.env` files to Git.",
    category: "DevOps",
    difficulty: "EASY" as const,
    tags: ["environment-variables", "configuration", "devops"],
  },
  {
    questionText: "What is TypeScript and why use it for full-stack development?",
    idealAnswer: "TypeScript adds static types to JavaScript — interfaces, generics, enums, union types. Benefits for full-stack: shared types between frontend and backend (monorepo packages), catch errors at compile time, better IDE support, self-documenting code. Used with React (typed props/state), Node.js (typed handlers), and Prisma (generated types from schema). Compilation step adds minimal overhead.",
    category: "TypeScript",
    difficulty: "EASY" as const,
    tags: ["typescript", "full-stack", "types"],
  },
  {
    questionText: "What is Docker and how does it help in full-stack development?",
    idealAnswer: "Docker packages applications into containers — lightweight, isolated environments with all dependencies. `Dockerfile` defines the image, `docker-compose.yml` orchestrates multiple services (app, database, Redis). Benefits: consistent environments across dev/staging/prod, easy setup for new developers, microservices isolation. Full-stack use: run PostgreSQL, Redis, MinIO locally without installing each separately.",
    category: "DevOps",
    difficulty: "EASY" as const,
    tags: ["docker", "containers", "devops"],
  },
  {
    questionText: "What is a monorepo and what are its benefits?",
    idealAnswer: "A monorepo stores multiple projects/packages in a single repository. Benefits: shared code (types, utilities), atomic commits across projects, consistent tooling/linting, easier refactoring. Tools: npm workspaces, Turborepo, Nx. Example: frontend + backend + shared packages in one repo. Trade-offs: larger repo size, CI complexity, access control challenges. Works well for full-stack apps with shared types.",
    category: "Tooling",
    difficulty: "EASY" as const,
    tags: ["monorepo", "tooling", "architecture"],
  },
  {
    questionText: "What is CSS Flexbox and how does it work?",
    idealAnswer: "Flexbox is a one-dimensional layout model. Set `display: flex` on a container, then control children with: `flex-direction` (row/column), `justify-content` (main axis alignment), `align-items` (cross axis), `gap` (spacing), `flex-wrap` (wrapping). Children use `flex-grow`, `flex-shrink`, `flex-basis` to control sizing. Perfect for navigation bars, card layouts, centering content.",
    category: "CSS",
    difficulty: "EASY" as const,
    tags: ["css", "flexbox", "layout"],
  },
  {
    questionText: "What is state management in React?",
    idealAnswer: "State is data that changes over time and affects rendering. Local state: `useState` for component-specific data. Global state: Context API, Zustand, or Redux for shared data. Server state: React Query/TanStack Query for API data with caching. URL state: query parameters and route params. Choose the right level — not everything needs to be global. Lift state up only when siblings need it.",
    category: "React",
    difficulty: "EASY" as const,
    tags: ["react", "state-management", "frontend"],
  },
  {
    questionText: "What is middleware in Express.js?",
    idealAnswer: "Middleware functions process requests before they reach route handlers. They have access to req, res, and next(). Execute in order they're registered. Types: application (cors, helmet, express.json), route-specific (auth check), error handling (4 parameters). Common uses: logging, authentication, rate limiting, body parsing, CORS. Chain with `app.use()` for all routes or attach to specific routes.",
    category: "Node.js",
    difficulty: "EASY" as const,
    tags: ["express", "middleware", "backend"],
  },
  {
    questionText: "What is SQL and what are basic query types?",
    idealAnswer: "SQL (Structured Query Language) manages relational databases. Query types: SELECT (read), INSERT (create), UPDATE (modify), DELETE (remove). Clauses: WHERE (filter), JOIN (combine tables), GROUP BY (aggregate), ORDER BY (sort), LIMIT (paginate). Relationships: one-to-one, one-to-many, many-to-many (junction table). ORMs like Prisma generate SQL, but understanding raw SQL is essential for optimization.",
    category: "Databases",
    difficulty: "EASY" as const,
    tags: ["sql", "databases", "queries"],
  },
  {
    questionText: "What is CORS and how do you handle it?",
    idealAnswer: "CORS (Cross-Origin Resource Sharing) is a browser security mechanism restricting cross-domain requests. When frontend (localhost:3100) calls backend (localhost:3000), the browser blocks it unless the server sends CORS headers. Configure with the `cors` middleware in Express: specify allowed origins, methods, headers, and credentials. In production, whitelist specific domains rather than allowing all.",
    category: "Security",
    difficulty: "EASY" as const,
    tags: ["cors", "security", "http"],
  },
  {
    questionText: "What are React hooks? Name the most common ones.",
    idealAnswer: "Hooks let function components use React features. Common hooks: `useState` (local state), `useEffect` (side effects), `useContext` (context consumption), `useMemo` (memoize values), `useCallback` (memoize functions), `useRef` (mutable references/DOM access), `useReducer` (complex state). Rules: call at top level only, only in React components or custom hooks. Custom hooks encapsulate reusable logic.",
    category: "React",
    difficulty: "EASY" as const,
    tags: ["react", "hooks", "frontend"],
  },
  {
    questionText: "What is an ORM and what is Prisma?",
    idealAnswer: "An ORM maps database tables to programming objects, abstracting SQL. Prisma is a modern TypeScript ORM with: schema-first design (prisma.schema), auto-generated type-safe client, visual Studio browser, migration system. Query: `prisma.user.findMany({ where: { age: { gt: 18 } }, include: { posts: true } })`. Benefits: type safety, relation handling, no raw SQL for basic operations.",
    category: "Databases",
    difficulty: "EASY" as const,
    tags: ["orm", "prisma", "databases"],
  },
  {
    questionText: "What is JWT and how is it used for authentication?",
    idealAnswer: "JWT (JSON Web Token) has three parts: header (algorithm), payload (claims: userId, role, exp), signature. Server signs on login, client sends in Authorization header. Server verifies signature without database lookup (stateless). Store in httpOnly cookies (secure) not localStorage (XSS risk). Short expiry (15min) with refresh tokens for long sessions. Can't be revoked without a blocklist.",
    category: "Security",
    difficulty: "EASY" as const,
    tags: ["jwt", "authentication", "security"],
  },
  {
    questionText: "What is Next.js and why use it over plain React?",
    idealAnswer: "Next.js is a React framework adding: server-side rendering (better SEO, faster initial load), file-based routing, API routes, image optimization, built-in CSS support. App Router (v13+) adds Server Components, layouts, loading/error states. Benefits over CRA: SSR/SSG out of the box, automatic code splitting, built-in optimization. Ideal for full-stack apps where the frontend needs SEO and performance.",
    category: "Next.js",
    difficulty: "EASY" as const,
    tags: ["nextjs", "react", "framework"],
  },
  {
    questionText: "What is CI/CD and why is it important?",
    idealAnswer: "CI (Continuous Integration): automatically build and test code on every commit. CD (Continuous Delivery/Deployment): automatically deploy passing builds to staging/production. Tools: GitHub Actions, GitLab CI, Jenkins. Benefits: catch bugs early, consistent builds, faster releases, reduced manual errors. Pipeline: lint → test → build → deploy. Full-stack: test frontend and backend independently, deploy together or separately.",
    category: "DevOps",
    difficulty: "EASY" as const,
    tags: ["ci-cd", "devops", "automation"],
  },
  {
    questionText: "What is caching and what are common caching strategies?",
    idealAnswer: "Caching stores frequently accessed data for faster retrieval. Layers: browser cache (Cache-Control headers), CDN (static assets), application cache (Redis for API responses), database cache (query results). Strategies: cache-aside (read: check cache → miss → query DB → populate cache), write-through, TTL-based expiration. Use for: user sessions, API responses, computed results. Invalidate carefully to avoid stale data.",
    category: "Performance",
    difficulty: "EASY" as const,
    tags: ["caching", "redis", "performance"],
  },
  {
    questionText: "What is error handling in full-stack applications?",
    idealAnswer: "Backend: try/catch with custom error classes (AppError with status codes), error middleware in Express, proper HTTP status codes, structured error responses `{error: {message, code}}`. Frontend: error boundaries for React rendering errors, try/catch for async operations, toast notifications for user feedback, retry logic for transient failures. Log errors server-side with correlation IDs for debugging.",
    category: "Error Handling",
    difficulty: "EASY" as const,
    tags: ["error-handling", "backend", "frontend"],
  },
  {
    questionText: "What is database indexing and when should you add indexes?",
    idealAnswer: "An index is a data structure that speeds up data retrieval (like a book index). Add indexes on: columns in WHERE clauses, JOIN conditions, ORDER BY, and UNIQUE constraints. Trade-offs: faster reads but slower writes and extra storage. Types: B-tree (default, most queries), hash (equality), GIN (full-text, arrays). Use `EXPLAIN ANALYZE` to verify index usage. Don't index columns with low cardinality.",
    category: "Databases",
    difficulty: "EASY" as const,
    tags: ["databases", "indexing", "performance"],
  },

  // ===== MEDIUM (40 questions) =====
  {
    questionText: "How would you design the architecture for a full-stack e-commerce application?",
    idealAnswer: "Architecture: Next.js frontend (SSR for product pages, CSR for cart), Express API server, PostgreSQL + Prisma for data, Redis for sessions/caching, MinIO/S3 for product images. Key features: auth (JWT + refresh tokens), product catalog with search/filter, cart (Redis for guests, DB for users), checkout with payment integration (Stripe), order management. Use Zod for shared validation between frontend and API.",
    category: "Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["architecture", "e-commerce", "full-stack"],
  },
  {
    questionText: "Explain the difference between SSR, CSR, SSG, and ISR in Next.js.",
    idealAnswer: "CSR: renders in browser, fast navigation, poor SEO. SSR: renders on server per request, fresh data, good SEO, higher server cost. SSG: pre-built at build time, fastest load, stale until rebuild. ISR: SSG with background revalidation at configured intervals — combines speed with freshness. Choose SSG for static content, SSR for personalized/real-time data, ISR for content that updates periodically, CSR for authenticated dashboards.",
    category: "Next.js",
    difficulty: "MEDIUM" as const,
    tags: ["nextjs", "rendering", "ssr", "ssg"],
  },
  {
    questionText: "How do you handle authentication across frontend and backend?",
    idealAnswer: "Flow: (1) Frontend sends credentials to auth API, (2) Backend validates, returns JWT access token + refresh token in httpOnly cookies, (3) Frontend stores auth state (Zustand), (4) API requests include cookies automatically, (5) Backend middleware extracts/verifies JWT, sets userId on request, (6) Gateway forwards userId to downstream services. Refresh flow: interceptor catches 401, calls refresh endpoint, retries original request.",
    category: "Security",
    difficulty: "MEDIUM" as const,
    tags: ["authentication", "jwt", "full-stack"],
  },
  {
    questionText: "What is the N+1 query problem and how do you solve it?",
    idealAnswer: "N+1 occurs when fetching a list (1 query) then fetching related data for each item (N queries). Example: 100 users + 100 queries for their posts = 101 queries. Solutions: (1) Prisma `include` or `select` for eager loading (generates JOINs), (2) DataLoader pattern for batching (GraphQL), (3) Raw SQL with JOINs. In Prisma: `prisma.user.findMany({ include: { posts: true } })` generates a single JOIN query.",
    category: "Databases",
    difficulty: "MEDIUM" as const,
    tags: ["databases", "n-plus-1", "performance"],
  },
  {
    questionText: "How would you implement real-time features in a full-stack application?",
    idealAnswer: "Options: (1) WebSocket (Socket.IO) for bidirectional — chat, collaboration, (2) Server-Sent Events (SSE) for server-to-client — notifications, live feeds, (3) Long polling as fallback. Architecture: WebSocket server alongside REST API, Redis pub/sub for multi-server broadcasting. Frontend: React hooks wrapping WebSocket connection with auto-reconnect. Handle: connection state, offline queuing, authentication on connection.",
    category: "Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["real-time", "websocket", "sse"],
  },
  {
    questionText: "Explain how to implement form validation on both frontend and backend.",
    idealAnswer: "Use Zod schemas shared between frontend and backend in a monorepo package. Frontend: React Hook Form with zodResolver for instant client-side validation. Backend: validate request body with the same Zod schema in middleware. Benefits: single source of truth, type-safe, consistent error messages. Always validate on the backend regardless of frontend validation — client validation is for UX, server validation is for security.",
    category: "Validation",
    difficulty: "MEDIUM" as const,
    tags: ["validation", "zod", "forms"],
  },
  {
    questionText: "How do you handle file uploads in a full-stack application?",
    idealAnswer: "Frontend: `<input type='file'>` or drag-and-drop, preview before upload, client-side validation (size, type), FormData or presigned URL upload. Backend: multer middleware for multipart parsing, validate (magic bytes, size limits), store in S3/MinIO (not local filesystem), save metadata in DB. Presigned URLs allow direct browser-to-S3 upload, bypassing the server for large files. Return file URL/key for frontend display.",
    category: "Full Stack",
    difficulty: "MEDIUM" as const,
    tags: ["file-upload", "multer", "s3"],
  },
  {
    questionText: "What is the difference between optimistic and pessimistic UI updates?",
    idealAnswer: "Optimistic: update UI immediately before server confirms, roll back on failure. Fast, responsive UX but complex error handling. Example: liking a post — increment count instantly, revert if API fails. Pessimistic: wait for server confirmation before updating UI. Simpler, always consistent but slower. Use optimistic for reversible, low-risk actions (likes, toggles). Use pessimistic for critical actions (payments, deletes).",
    category: "Frontend",
    difficulty: "MEDIUM" as const,
    tags: ["optimistic-update", "ux", "state"],
  },
  {
    questionText: "How would you implement pagination in a full-stack app?",
    idealAnswer: "Backend: support offset-based (`?page=1&limit=20`) and/or cursor-based (`?cursor=abc&limit=20`) pagination. Return `{ data, meta: { total, page, pageSize, hasNext } }`. Use Prisma `skip`/`take` for offset, `cursor`/`take` for cursor. Frontend: page buttons for offset (admin tables), infinite scroll with Intersection Observer for cursor (feeds). TanStack Query supports both with `useInfiniteQuery`.",
    category: "Full Stack",
    difficulty: "MEDIUM" as const,
    tags: ["pagination", "api", "frontend"],
  },
  {
    questionText: "Explain how to set up a monorepo with shared TypeScript types.",
    idealAnswer: "Use npm workspaces: root `package.json` with `workspaces: ['packages/*', 'services/*', 'frontend']`. Shared types package: `packages/shared` with Zod schemas and TypeScript types. Services import via `@myapp/shared`. Configure `tsconfig.json` with project references. Build order: shared → services → frontend. Tools: Turborepo for caching and parallel builds. This ensures frontend and backend always agree on API types.",
    category: "Tooling",
    difficulty: "MEDIUM" as const,
    tags: ["monorepo", "typescript", "workspaces"],
  },
  {
    questionText: "How do you handle database migrations in a team environment?",
    idealAnswer: "Use Prisma Migrate: modify `schema.prisma`, run `prisma migrate dev --name description` to generate migration files. Commit migration files to Git. Team members pull and run `prisma migrate dev` to apply. Never edit existing migrations — create new ones. In production: `prisma migrate deploy` applies pending migrations. For breaking changes: use expand-contract pattern. Test migrations on production-sized data before deploying.",
    category: "Databases",
    difficulty: "MEDIUM" as const,
    tags: ["migrations", "prisma", "databases"],
  },
  {
    questionText: "What is server-side rendering and how does hydration work?",
    idealAnswer: "SSR renders React components to HTML on the server, sending complete markup to the browser. The browser displays content immediately (fast FCP), then React 'hydrates' — attaches event listeners and makes it interactive. During hydration, React reconciles its Virtual DOM with the existing DOM. Mismatches cause hydration errors. Next.js handles SSR automatically for Server Components and `use server` marked routes.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["ssr", "hydration", "nextjs"],
  },
  {
    questionText: "How would you implement role-based access control across frontend and backend?",
    idealAnswer: "Backend: JWT contains user role, middleware checks required role per endpoint, database stores User → Role → Permission mappings. Frontend: auth store holds role, conditional rendering hides unauthorized UI, route guards redirect unauthorized access. Never rely on frontend-only protection — always enforce on backend. Types: simple roles (USER, ADMIN), permission-based (can:create:post), hierarchical (admin inherits editor permissions).",
    category: "Security",
    difficulty: "MEDIUM" as const,
    tags: ["rbac", "authorization", "full-stack"],
  },
  {
    questionText: "Explain how to implement error handling across the full stack.",
    idealAnswer: "Backend: custom AppError class with status code, error middleware catches and formats errors, structured responses `{success: false, error: {message, code}}`. Frontend: Axios interceptor for global error handling, React error boundaries for rendering errors, toast notifications for user feedback, retry logic for transient failures. Logging: structured logs with correlation IDs, error tracking (Sentry) for both frontend and backend.",
    category: "Error Handling",
    difficulty: "MEDIUM" as const,
    tags: ["error-handling", "full-stack", "sentry"],
  },
  {
    questionText: "How do you optimize API response times?",
    idealAnswer: "Techniques: (1) Database: indexing, query optimization, connection pooling, (2) Caching: Redis for frequent queries, HTTP Cache-Control headers, (3) Pagination: don't return all records, (4) Select only needed fields (Prisma `select`), (5) Compression: gzip/brotli for responses, (6) Parallel queries where possible (`Promise.all`), (7) CDN for static assets, (8) Connection keep-alive. Measure with: request timing middleware, APM tools (Datadog, New Relic).",
    category: "Performance",
    difficulty: "MEDIUM" as const,
    tags: ["performance", "optimization", "api"],
  },
  {
    questionText: "What is a WebSocket and how would you implement a chat feature?",
    idealAnswer: "WebSocket provides persistent bidirectional connection. Chat implementation: (1) Socket.IO server with rooms per conversation, (2) Client connects on entering chat, joins room, (3) Send message → server broadcasts to room members, (4) Persist messages to DB asynchronously, (5) Handle: typing indicators, read receipts, online status, reconnection, message history on connect. Scale with Redis adapter for multi-server. Use message queue for offline message delivery.",
    category: "Real-time",
    difficulty: "MEDIUM" as const,
    tags: ["websocket", "chat", "socket-io"],
  },
  {
    questionText: "How do you handle image optimization in a full-stack application?",
    idealAnswer: "Upload pipeline: validate type/size, generate multiple sizes (sharp), convert to WebP/AVIF, store originals in S3/MinIO. Serving: Next.js `Image` component handles lazy loading, responsive srcset, and format negotiation automatically. CDN for caching. Use blur hash for placeholders during load. Set Cache-Control headers. Consider: client-side compression before upload, background processing via job queue for large batches.",
    category: "Performance",
    difficulty: "MEDIUM" as const,
    tags: ["images", "optimization", "nextjs"],
  },
  {
    questionText: "Explain the concept of middleware in a full-stack context (both Express and Next.js).",
    idealAnswer: "Express middleware: functions in the request pipeline that can modify req/res, authenticate, log, rate limit, parse body. Executed in registration order. Next.js middleware: runs at the edge before rendering, defined in `middleware.ts`. Used for: auth checks, redirects, geolocation, A/B testing. Both intercept requests before they reach handlers. Express middleware is for API routes; Next.js middleware is for page routes and can rewrite/redirect.",
    category: "Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["middleware", "express", "nextjs"],
  },
  {
    questionText: "How do you implement search functionality across the stack?",
    idealAnswer: "Backend: PostgreSQL full-text search with `tsvector`/`tsquery` for simple needs, Elasticsearch for advanced (facets, fuzzy, autocomplete). API: `/search?q=term&filters=...` with pagination. Frontend: debounced search input, loading states, result highlighting, filter sidebar, search suggestions (autocomplete). Prisma: use `contains` for simple search, raw SQL for full-text. Index searchable columns. Cache popular queries.",
    category: "Full Stack",
    difficulty: "MEDIUM" as const,
    tags: ["search", "full-text-search", "full-stack"],
  },
  {
    questionText: "What are React Server Components and how do they affect full-stack development?",
    idealAnswer: "Server Components render on the server, sending only HTML (zero JS bundle). They can directly access databases, file systems, and secrets. Client Components (marked `'use client'`) handle interactivity. Impact on full-stack: Server Components can replace some API endpoints — query DB directly in the component. Reduces API surface area. Pattern: Server Component fetches data, passes to Client Component for interactivity. Changes the traditional frontend-backend boundary.",
    category: "Next.js",
    difficulty: "MEDIUM" as const,
    tags: ["rsc", "nextjs", "full-stack"],
  },
  {
    questionText: "How would you implement a notification system across the stack?",
    idealAnswer: "Architecture: (1) Backend events trigger notifications (new message, order update), (2) Store in DB (Notification model with userId, type, content, read status), (3) Real-time delivery via WebSocket/SSE to connected clients, (4) Push notifications for offline users (web push API), (5) Frontend: notification bell with unread count, dropdown list, mark-as-read API. Batch similar notifications. Allow per-type preferences (email, push, in-app).",
    category: "Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["notifications", "real-time", "full-stack"],
  },
  {
    questionText: "Explain how to implement data fetching patterns in Next.js App Router.",
    idealAnswer: "Patterns: (1) Server Components fetch data directly (no useEffect needed, no client JS), (2) `fetch()` with caching options: `cache: 'force-cache'` (SSG), `cache: 'no-store'` (SSR), `next: { revalidate: 60 }` (ISR), (3) Parallel fetching with `Promise.all` in Server Components, (4) Streaming with Suspense for progressive loading, (5) Client-side: TanStack Query for interactive data (mutations, polling). Avoid waterfalls by fetching data at the layout level.",
    category: "Next.js",
    difficulty: "MEDIUM" as const,
    tags: ["nextjs", "data-fetching", "app-router"],
  },
  {
    questionText: "How do you handle environment-specific configuration across frontend and backend?",
    idealAnswer: "Backend: `.env` files per environment (.env.development, .env.production), loaded by dotenv. Platform env vars in production (Railway, Vercel). Frontend (Next.js): `NEXT_PUBLIC_` prefix for client-accessible vars, server-only vars without prefix. Shared config package in monorepo for common validation. Never expose secrets to the frontend. Validate required env vars at startup to fail fast.",
    category: "DevOps",
    difficulty: "MEDIUM" as const,
    tags: ["environment", "configuration", "full-stack"],
  },
  {
    questionText: "What is API rate limiting and how do you implement it full-stack?",
    idealAnswer: "Backend: use express-rate-limit or Redis-based sliding window. Configure per-endpoint limits (100/min for public, 1000/min for authenticated). Return 429 with Retry-After header. Frontend: respect rate limits — show user-friendly error, implement client-side throttling for rapid actions, display remaining quota from response headers. API gateway is the best place for centralized rate limiting across microservices.",
    category: "Security",
    difficulty: "MEDIUM" as const,
    tags: ["rate-limiting", "security", "full-stack"],
  },
  {
    questionText: "How do you handle database relationships in Prisma?",
    idealAnswer: "Prisma supports: one-to-one (`@relation` with unique foreign key), one-to-many (foreign key on 'many' side), many-to-many (implicit join table or explicit). Define in schema: `posts Post[]` on User, `author User @relation(fields: [authorId], references: [id])` on Post. Query with `include` (full object) or `select` (specific fields). Cascading deletes with `onDelete: Cascade`. Use `@@index` for foreign key performance.",
    category: "Databases",
    difficulty: "MEDIUM" as const,
    tags: ["prisma", "relationships", "databases"],
  },
  {
    questionText: "How would you implement a testing strategy for a full-stack application?",
    idealAnswer: "Backend: unit tests (Jest) for services/utilities, integration tests with test database (Prisma with Docker), API tests (supertest). Frontend: component tests (React Testing Library), integration tests with MSW for API mocking, visual regression. E2E: Playwright for critical flows (login, checkout). CI pipeline: lint → unit tests → integration tests → E2E → deploy. Test coverage targets: 80% for business logic, 100% for auth/payments.",
    category: "Testing",
    difficulty: "MEDIUM" as const,
    tags: ["testing", "jest", "playwright"],
  },
  {
    questionText: "How do you implement logging and monitoring in a full-stack app?",
    idealAnswer: "Backend: structured JSON logging (Pino/Winston), request ID correlation, log levels (error, warn, info, debug). Frontend: error tracking (Sentry), performance monitoring (Web Vitals), user analytics. Centralized logging: ELK stack or Datadog. Monitoring: health check endpoints, uptime monitors, alerting on error rate spikes. Include: request duration, status codes, user context. Never log passwords or tokens.",
    category: "Observability",
    difficulty: "MEDIUM" as const,
    tags: ["logging", "monitoring", "observability"],
  },
  {
    questionText: "Explain how to implement dark mode across the full stack.",
    idealAnswer: "Frontend: CSS custom properties for theme tokens, `prefers-color-scheme` media query for OS default, class toggle (`dark`) on html element, persist preference in localStorage. Tailwind: `dark:` variant with `darkMode: 'class'`. Server: send theme preference cookie so SSR renders correct theme (avoids flash). Store user preference in DB for cross-device sync. Apply theme at layout level to prevent flash of wrong theme.",
    category: "Frontend",
    difficulty: "MEDIUM" as const,
    tags: ["dark-mode", "theming", "css"],
  },
  {
    questionText: "What is database seeding and how do you implement it?",
    idealAnswer: "Seeding populates a database with initial/test data. Prisma: `prisma/seed.ts` script run via `prisma db seed`. Create default admin users, job roles, skill categories, test data. Use upsert to be idempotent (re-runnable). Separate: essential seed data (roles, permissions) from development data (fake users). Use Faker.js for realistic test data. Seed runs after migrations in CI/CD pipeline.",
    category: "Databases",
    difficulty: "MEDIUM" as const,
    tags: ["seeding", "prisma", "databases"],
  },
  {
    questionText: "How do you handle API versioning in a full-stack application?",
    idealAnswer: "Backend: URL-based versioning (`/api/v1/users`, `/api/v2/users`) is most common. Route to different handlers per version. Support at least one prior version. Frontend: configure API base URL per version, update when ready. Deprecation strategy: communicate timeline, add deprecation headers, log usage of old versions. In a monorepo: version in API gateway routing, individual services handle their own versioning.",
    category: "APIs",
    difficulty: "MEDIUM" as const,
    tags: ["api-versioning", "api", "full-stack"],
  },
  {
    questionText: "How do you deploy a full-stack application?",
    idealAnswer: "Options: (1) Platform-as-a-Service: Vercel (frontend) + Railway (backend + DB), (2) Docker Compose on a VPS, (3) Kubernetes for scale. Pipeline: push to Git → CI runs tests → build Docker images → deploy to staging → smoke tests → deploy to production. Database: run migrations before deploying new code. Zero-downtime: rolling updates, health checks. Environment variables per stage. Monitor after deploy for errors.",
    category: "DevOps",
    difficulty: "MEDIUM" as const,
    tags: ["deployment", "devops", "ci-cd"],
  },
  {
    questionText: "How would you implement a dashboard with charts and analytics?",
    idealAnswer: "Backend: aggregation queries (GROUP BY, date functions) returning time-series data. Cache expensive queries in Redis with TTL. API endpoints: `/analytics/summary`, `/analytics/trends?period=7d`. Frontend: charting library (Recharts, Chart.js, or Tremor for React). Server Components for initial data, client components for interactive filters. Implement: date range picker, exportable data, responsive chart layouts. Consider materialized views for complex aggregations.",
    category: "Full Stack",
    difficulty: "MEDIUM" as const,
    tags: ["analytics", "charts", "dashboard"],
  },

  // ===== HARD (30 questions) =====
  {
    questionText: "How would you design a microservices architecture for a large-scale application?",
    idealAnswer: "Design: (1) Identify bounded contexts — each service owns its domain and data, (2) API gateway for routing, auth, rate limiting, (3) Inter-service communication: synchronous (REST/gRPC) for queries, async (message queue) for events, (4) Database per service, (5) Service discovery and health checks, (6) Distributed tracing (OpenTelemetry) for debugging, (7) Circuit breakers for resilience. Start monolith, extract services when team/scale demands. Avoid distributed monolith anti-pattern.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["microservices", "architecture", "system-design"],
  },
  {
    questionText: "How do you handle distributed transactions across multiple services?",
    idealAnswer: "Saga pattern: sequence of local transactions with compensating actions on failure. Types: (1) Choreography — services emit events, listeners react (simpler, but harder to trace), (2) Orchestration — central coordinator directs the flow (clearer, but single point of coordination). Each step must be idempotent. Use the outbox pattern to reliably publish events from within a DB transaction. Embrace eventual consistency — not everything needs immediate consistency.",
    category: "Distributed Systems",
    difficulty: "HARD" as const,
    tags: ["saga", "distributed-transactions", "microservices"],
  },
  {
    questionText: "Explain how to implement a scalable real-time collaboration system.",
    idealAnswer: "Architecture: (1) CRDTs (Yjs) for conflict-free document merging, (2) WebSocket server per region with Redis pub/sub for cross-server broadcasting, (3) Awareness protocol for cursor positions and user presence, (4) Persistence: save document snapshots + incremental updates to DB, (5) Offline support: local-first with sync on reconnect, (6) Access control: permission checks on connection and document level, (7) History/versioning for undo and audit trail. Scale WebSocket servers horizontally behind a load balancer with sticky sessions.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["collaboration", "crdt", "real-time"],
  },
  {
    questionText: "How would you design a robust CI/CD pipeline for a full-stack monorepo?",
    idealAnswer: "Pipeline: (1) Trigger: PR creation and merge, (2) Affected packages detection (Turborepo `--filter=...[HEAD^]`), (3) Parallel stages: lint + type-check + unit tests for affected packages, (4) Integration tests with Docker Compose (real DB), (5) Build all affected packages, (6) E2E tests against staging, (7) Deploy: Vercel preview for frontend, Docker images for services, database migrations, (8) Post-deploy: smoke tests, monitoring. Cache: Turborepo remote cache, Docker layer cache, npm cache.",
    category: "DevOps",
    difficulty: "HARD" as const,
    tags: ["ci-cd", "monorepo", "devops"],
  },
  {
    questionText: "How do you handle database schema changes with zero downtime?",
    idealAnswer: "Expand-contract pattern: (1) Expand: add new column/table without removing old ones, deploy code that writes to both, backfill data, (2) Migrate: deploy code that reads from new, verify correctness, (3) Contract: remove old column in a later deploy. Never rename/drop columns in the same deploy as code changes. Use Prisma's shadow database for safe migration generation. Test migrations on production-size datasets. Always have a rollback plan.",
    category: "Databases",
    difficulty: "HARD" as const,
    tags: ["migrations", "zero-downtime", "databases"],
  },
  {
    questionText: "Explain how to implement end-to-end type safety in a full-stack TypeScript application.",
    idealAnswer: "Stack: (1) Prisma generates DB types from schema, (2) Shared Zod schemas in monorepo package validate request/response, (3) `z.infer<typeof schema>` generates TypeScript types from Zod, (4) tRPC or typed API client ensures frontend calls match backend contracts, (5) React components use the same types for props. Any schema change propagates type errors across the entire stack at compile time. This eliminates runtime type mismatches between frontend and backend.",
    category: "TypeScript",
    difficulty: "HARD" as const,
    tags: ["typescript", "type-safety", "full-stack"],
  },
  {
    questionText: "How would you implement a multi-tenant SaaS application?",
    idealAnswer: "Data isolation options: shared schema with tenantId (simplest, most common), separate schemas, or separate databases. Implementation: (1) Tenant resolution from subdomain/header, (2) Middleware injects tenantId into every query, (3) PostgreSQL Row Level Security for database-level enforcement, (4) Prisma middleware to automatically filter by tenantId, (5) Separate storage buckets per tenant, (6) Tenant-aware caching (namespace keys), (7) Billing per tenant with usage metering. Frontend: tenant-specific theming and branding via CSS variables.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["multi-tenancy", "saas", "architecture"],
  },
  {
    questionText: "How do you optimize a full-stack application for performance at scale?",
    idealAnswer: "Backend: connection pooling, query optimization (EXPLAIN ANALYZE), Redis caching, read replicas, horizontal scaling with load balancer. API: pagination, field selection, compression, CDN for static assets. Frontend: code splitting, tree shaking, image optimization, lazy loading, SSR for initial load. Database: indexing, materialized views, partitioning. Infrastructure: auto-scaling, CDN, regional deployment. Profile before optimizing — measure, don't guess.",
    category: "Performance",
    difficulty: "HARD" as const,
    tags: ["performance", "scaling", "optimization"],
  },
  {
    questionText: "Design a comprehensive authentication system with SSO, MFA, and social login.",
    idealAnswer: "Architecture: (1) Auth service: local credentials + OAuth 2.0/OIDC for social (Google, GitHub), (2) SAML/OIDC for enterprise SSO, (3) MFA: TOTP (Google Authenticator) or WebAuthn (passkeys), (4) Token management: short-lived JWT access tokens + refresh token rotation in httpOnly cookies, (5) Session management: device tracking, concurrent session limits, (6) Account linking: connect multiple auth methods to one account, (7) Password: bcrypt hashing, breach detection (Have I Been Pwned API). Frontend: unified login page with provider buttons, MFA verification step.",
    category: "Security",
    difficulty: "HARD" as const,
    tags: ["authentication", "sso", "mfa"],
  },
  {
    questionText: "How would you implement a job queue system for background processing?",
    idealAnswer: "Use BullMQ with Redis: (1) Define queues per job type (emails, image processing, reports), (2) Producer adds jobs with data, priority, delay, (3) Worker processes jobs concurrently with configurable concurrency, (4) Handle: retries with exponential backoff, dead letter queue, job progress events, (5) Dashboard (Bull Board) for monitoring, (6) Graceful shutdown (drain queue before stopping), (7) Separate worker processes from API servers, (8) Job scheduling with cron patterns for recurring tasks. Scale workers independently.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["job-queue", "bullmq", "background-processing"],
  },
  {
    questionText: "Explain how to implement a caching strategy across multiple layers.",
    idealAnswer: "Layers: (1) Browser: Cache-Control headers (max-age, stale-while-revalidate), ETags for conditional requests, (2) CDN: cache static assets and SSR pages at edge, (3) API gateway: response caching for GET endpoints, (4) Application: Redis for computed results, session data, rate limit counters, (5) Database: query cache, materialized views. Invalidation: TTL for temporal, event-driven for data changes, versioned keys for gradual rollout. Cache-aside pattern for most application caching.",
    category: "Performance",
    difficulty: "HARD" as const,
    tags: ["caching", "redis", "performance"],
  },
  {
    questionText: "How do you implement proper security hardening for a production full-stack app?",
    idealAnswer: "Backend: helmet.js (security headers), rate limiting, input validation (Zod), parameterized queries, CORS whitelist, CSRF protection, dependency auditing (npm audit). Frontend: CSP headers, XSS prevention (React auto-escapes), secure cookie flags. Infrastructure: HTTPS everywhere, secrets in vault/env, minimal Docker images, non-root containers, network policies. Auth: bcrypt for passwords, JWT with short expiry, refresh token rotation. Regular penetration testing.",
    category: "Security",
    difficulty: "HARD" as const,
    tags: ["security", "hardening", "production"],
  },
  {
    questionText: "How would you design an offline-first application with data synchronization?",
    idealAnswer: "Architecture: (1) Service Worker caches static assets and API responses, (2) IndexedDB (via Dexie.js) stores structured data locally, (3) Optimistic writes to local DB first, queue changes for sync, (4) Background Sync API sends queued changes when online, (5) Conflict resolution: last-write-wins for simple data, CRDT for collaborative data, (6) Version vectors for detecting conflicts, (7) Delta sync to minimize data transfer. Frontend: show connection status, queue indicators, sync progress. Test with throttled networks.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["offline-first", "pwa", "sync"],
  },
  {
    questionText: "How do you implement a content management system with draft/publish workflow?",
    idealAnswer: "Schema: Content model with `status` (DRAFT, REVIEW, PUBLISHED, ARCHIVED), `publishedAt`, `version` fields. Separate `ContentVersion` table for version history. API: `POST /content` (create draft), `PATCH /content/:id/submit` (request review), `PATCH /content/:id/publish` (go live), `POST /content/:id/revert/:version`. Frontend: rich text editor (TipTap/Plate), preview mode, version diff viewer. Role-based: editors draft, reviewers approve, admins publish. Scheduled publishing via job queue.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["cms", "workflow", "architecture"],
  },
  {
    questionText: "How would you implement a payment system with Stripe/Razorpay integration?",
    idealAnswer: "Architecture: (1) Frontend creates payment intent via backend API, (2) Backend: create order record, call payment gateway to create intent/order, (3) Frontend: render Stripe Elements or Razorpay checkout, (4) Gateway processes payment client-side (PCI compliant), (5) Webhook handler receives payment confirmation, updates order status, (6) Idempotency keys prevent duplicate charges, (7) Retry failed webhook deliveries, (8) Reconciliation job verifies payments match orders. Never store card data. Handle: refunds, disputes, subscription billing.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["payments", "stripe", "architecture"],
  },
  {
    questionText: "Explain how to build a system that handles 100K+ concurrent users.",
    idealAnswer: "Infrastructure: (1) CDN for static assets and edge caching, (2) Load balancer (ALB/HAProxy) distributing to auto-scaling app server group, (3) Read replicas for database, (4) Redis cluster for caching and sessions, (5) Connection pooling (PgBouncer), (6) Async processing for non-critical paths (queues). Application: stateless services, efficient queries, selective caching, pagination. Frontend: SSG where possible, code splitting, lazy loading. Database: indexing, partitioning, query optimization. Monitor and scale based on metrics.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["scaling", "high-traffic", "architecture"],
  },
  {
    questionText: "How do you implement comprehensive error tracking and debugging in production?",
    idealAnswer: "Stack: (1) Sentry for error tracking (frontend + backend), (2) Structured logging with correlation IDs (request → all service logs), (3) Source maps uploaded to Sentry for frontend stack traces, (4) OpenTelemetry for distributed tracing across microservices, (5) Custom error classes with context (userId, action, resource), (6) Alerting: PagerDuty/Slack for error rate spikes, (7) Error budgets and SLOs. Debug flow: alert → Sentry error → correlation ID → distributed trace → root cause. Reproduce with logged request context.",
    category: "Observability",
    difficulty: "HARD" as const,
    tags: ["error-tracking", "debugging", "sentry"],
  },
  {
    questionText: "How would you design an event-driven architecture for a complex application?",
    idealAnswer: "Architecture: (1) Events as first-class citizens — domain events (OrderPlaced, UserRegistered), (2) Event bus: Kafka for high throughput, RabbitMQ for routing, Redis Streams for simplicity, (3) Outbox pattern: write events in same DB transaction as data, poll/CDC to publish, (4) Schema registry for event versioning, (5) Event store for audit trail, (6) Saga orchestrator for multi-step workflows. Benefits: loose coupling, scalability, audit trail. Challenges: eventual consistency, debugging event flows, exactly-once processing.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["event-driven", "kafka", "architecture"],
  },
  {
    questionText: "How do you implement a feature flag system across frontend and backend?",
    idealAnswer: "Architecture: (1) Feature flag service with admin UI, (2) Backend SDK evaluates flags per request (user attributes, percentage rollout), (3) Cache flags in Redis with short TTL, (4) Frontend: fetch flags at app load, store in context, conditionally render features, (5) SSR: evaluate flags server-side for consistent initial render, (6) Types: boolean toggle, percentage rollout, user targeting, A/B testing variants. Support: gradual rollout, kill switch, experimentation. Clean up stale flags regularly.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["feature-flags", "architecture", "full-stack"],
  },
  {
    questionText: "How would you implement a GraphQL API alongside an existing REST API?",
    idealAnswer: "Strategy: (1) GraphQL as a BFF (Backend for Frontend) that wraps existing REST services, (2) Apollo Server or Yoga on top of Express, (3) Schema-first design with resolvers calling existing service functions, (4) DataLoader for batching to prevent N+1 at resolver level, (5) Subscriptions for real-time via WebSocket, (6) Frontend: Apollo Client with cache management, (7) Gradual migration: new features in GraphQL, old endpoints remain REST. Benefits: flexible queries for complex frontend needs while keeping simple REST endpoints for external APIs.",
    category: "APIs",
    difficulty: "HARD" as const,
    tags: ["graphql", "rest", "api"],
  },
  {
    questionText: "How do you handle data privacy and GDPR compliance in a full-stack application?",
    idealAnswer: "Implementation: (1) Consent management: track and enforce user consent for data processing, (2) Data inventory: document what data is collected, where stored, how long retained, (3) Right to access: API endpoint exporting all user data (JSON), (4) Right to deletion: cascade delete across all services and backups, (5) Data minimization: collect only necessary data, (6) Encryption: at rest (AES-256) and in transit (TLS), (7) Audit logging for data access, (8) Privacy-by-design: pseudonymization, data retention policies. Frontend: cookie consent banner, privacy settings page.",
    category: "Security",
    difficulty: "HARD" as const,
    tags: ["gdpr", "privacy", "compliance"],
  },
  {
    questionText: "Explain how to implement server-side rendering with streaming in Next.js.",
    idealAnswer: "Streaming SSR sends HTML progressively as components resolve: (1) Wrap async components in `<Suspense fallback={<Skeleton />}>`, (2) Shell renders immediately with fallbacks, (3) As data resolves, React streams HTML chunks that replace fallbacks, (4) No full-page waterfall — each section loads independently, (5) Combine with `loading.tsx` for route-level streaming. Benefits: faster TTFB, progressive loading. Works with Server Components. Use `generateMetadata` for SEO (metadata sent first). Ideal for pages with mixed fast/slow data sources.",
    category: "Next.js",
    difficulty: "HARD" as const,
    tags: ["streaming", "ssr", "nextjs"],
  },
  {
    questionText: "How would you implement a recommendation engine in a full-stack app?",
    idealAnswer: "Approaches: (1) Collaborative filtering: track user interactions (views, likes, purchases), find similar users, recommend what they liked, (2) Content-based: extract features (tags, categories), recommend similar items, (3) Hybrid: combine both. Implementation: batch-compute recommendations (Spark/Python script), store in Redis for fast retrieval. API: `/recommendations?userId=X&limit=10`. ML model: train offline, serve predictions via API. Start simple (popular items, recent interactions), iterate with data.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["recommendations", "ml", "architecture"],
  },
  {
    questionText: "How do you implement proper database backup and disaster recovery?",
    idealAnswer: "Strategy: (1) Automated backups: PostgreSQL `pg_dump` scheduled daily, continuous WAL archiving for point-in-time recovery, (2) Backup storage: encrypted, different region from primary, (3) Retention: daily for 30 days, weekly for 6 months, monthly for years, (4) Test restores monthly, (5) Replication: streaming replication to standby server, (6) RTO/RPO targets: define acceptable downtime and data loss, (7) Runbook for failover procedures. Cloud: use managed database backups (RDS automated backups). Include application data (S3 objects) in backup strategy.",
    category: "DevOps",
    difficulty: "HARD" as const,
    tags: ["backup", "disaster-recovery", "databases"],
  },
  {
    questionText: "How would you implement an API gateway for a microservices architecture?",
    idealAnswer: "Functions: (1) Request routing based on path/headers to downstream services, (2) Authentication: JWT verification, extract user context, (3) Rate limiting per user/endpoint, (4) Request/response transformation, (5) Circuit breaking for failing services, (6) Logging and distributed tracing (inject correlation IDs), (7) CORS and security headers, (8) Response caching for GET endpoints. Implementation: Express.js with http-proxy-middleware, or dedicated solutions (Kong, AWS API Gateway). Keep the gateway thin — no business logic.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["api-gateway", "microservices", "architecture"],
  },
  {
    questionText: "How do you implement database connection management across microservices?",
    idealAnswer: "Strategy: (1) Each service has its own connection pool configured for its load, (2) PgBouncer as external pooler for serverless or high-connection scenarios, (3) Pool size = CPU cores × 2 + disk spindles per service, (4) Total connections across all services must not exceed PostgreSQL max_connections, (5) Separate databases or schemas per service for isolation, (6) Read replicas for read-heavy services, (7) Connection health checks and auto-reconnect, (8) Graceful shutdown: drain connections before stopping. Monitor: active connections, wait time, pool utilization.",
    category: "Databases",
    difficulty: "HARD" as const,
    tags: ["databases", "connection-pool", "microservices"],
  },
  {
    questionText: "How would you implement a comprehensive testing strategy for a microservices monorepo?",
    idealAnswer: "Pyramid: (1) Unit tests per service (Jest, fast, mocked dependencies), (2) Integration tests: each service with real DB (Docker test containers), test API contracts, (3) Contract tests (Pact) between services to verify API compatibility, (4) E2E tests (Playwright): critical user flows through the full stack, (5) Performance tests (k6): load testing key endpoints. CI: run affected tests only (Turborepo), parallel execution, test DB per pipeline. Coverage gates: fail CI below thresholds. Shift-left: most tests should be fast unit/integration tests.",
    category: "Testing",
    difficulty: "HARD" as const,
    tags: ["testing", "microservices", "monorepo"],
  },
  {
    questionText: "How do you manage state across server and client components in Next.js?",
    idealAnswer: "Patterns: (1) Server Components fetch and pass data as props to Client Components, (2) URL state (searchParams) for shareable state — Server Components read it directly, (3) Server Actions for mutations that update server state, (4) Client state (Zustand/Context) for purely interactive state (modals, selections), (5) React cache() for deduplicating server-side fetches in a single request, (6) Cookies for user preferences accessible in both. Avoid: lifting client state to server or prop drilling across the boundary. Keep server state in server, client state in client.",
    category: "Next.js",
    difficulty: "HARD" as const,
    tags: ["nextjs", "state", "server-components"],
  },
  {
    questionText: "How would you implement a plugin/extension system for a web application?",
    idealAnswer: "Architecture: (1) Define plugin API with lifecycle hooks (onInit, onRoute, onRender), (2) Plugin registry with metadata (name, version, permissions), (3) Sandboxed execution (iframe or Web Workers for untrusted plugins), (4) Event system for plugin-to-host communication, (5) Backend: plugin endpoints mounted dynamically, middleware injection points, (6) Frontend: slot/portal system for UI extension points, (7) Permission model: plugins declare required permissions, users approve. Examples: VS Code extensions, WordPress plugins, Shopify apps. Use dynamic imports for lazy loading.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["plugins", "extensibility", "architecture"],
  },
  {
    questionText: "Explain how to implement a data pipeline for analytics in a full-stack app.",
    idealAnswer: "Pipeline: (1) Frontend SDK captures user events (page views, clicks, feature usage) with batching, (2) Ingestion API receives events, validates schema, writes to Kafka/Redis Stream, (3) Stream processor (Node.js worker) enriches events (user info, geo), (4) Storage: ClickHouse/TimescaleDB for time-series analytics, S3 for raw events, (5) Aggregation jobs compute daily/weekly metrics, (6) Dashboard API serves pre-computed aggregates, (7) Real-time counters in Redis for live dashboards. Handle: late events, deduplication, schema evolution, data retention policies.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["analytics", "data-pipeline", "architecture"],
  },
];
