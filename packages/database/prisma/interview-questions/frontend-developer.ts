export const frontendDeveloperQuestions = [
  // ===== EASY (30 questions) =====
  {
    questionText: "What is the difference between `let`, `const`, and `var` in JavaScript?",
    idealAnswer: "`var` is function-scoped and hoisted, `let` is block-scoped and not hoisted to usable state, `const` is block-scoped and cannot be reassigned after declaration. Prefer `const` by default, `let` when reassignment is needed, and avoid `var` in modern code.",
    category: "JavaScript",
    difficulty: "EASY" as const,
    tags: ["javascript", "variables", "scoping"],
  },
  {
    questionText: "What is the CSS box model?",
    idealAnswer: "The CSS box model describes the rectangular boxes generated for elements: content (inner area), padding (space between content and border), border (surrounds padding), and margin (space outside the border). `box-sizing: border-box` makes width/height include padding and border, which simplifies layout calculations.",
    category: "CSS",
    difficulty: "EASY" as const,
    tags: ["css", "box-model", "layout"],
  },
  {
    questionText: "What is the Virtual DOM and why do frameworks like React use it?",
    idealAnswer: "The Virtual DOM is a lightweight in-memory representation of the real DOM. When state changes, React creates a new Virtual DOM tree, diffs it against the previous one, and applies only the minimal necessary changes to the real DOM. This batching and diffing is faster than directly manipulating the DOM for complex UIs.",
    category: "React",
    difficulty: "EASY" as const,
    tags: ["react", "virtual-dom", "performance"],
  },
  {
    questionText: "What are semantic HTML elements? Give examples.",
    idealAnswer: "Semantic elements convey meaning about their content to browsers and assistive technologies. Examples: `<header>`, `<nav>`, `<main>`, `<article>`, `<section>`, `<aside>`, `<footer>`. They improve accessibility, SEO, and code readability compared to generic `<div>` and `<span>` elements.",
    category: "HTML",
    difficulty: "EASY" as const,
    tags: ["html", "semantics", "accessibility"],
  },
  {
    questionText: "What is the difference between `==` and `===` in JavaScript?",
    idealAnswer: "`==` performs type coercion before comparison (e.g., `'5' == 5` is true), while `===` checks both value and type without coercion (e.g., `'5' === 5` is false). Always prefer `===` to avoid unexpected coercion bugs.",
    category: "JavaScript",
    difficulty: "EASY" as const,
    tags: ["javascript", "operators", "comparison"],
  },
  {
    questionText: "What is responsive design and how do you implement it?",
    idealAnswer: "Responsive design makes web pages render well across different screen sizes. Key techniques: CSS media queries to apply different styles at breakpoints, fluid layouts with percentages or flexbox/grid, responsive images with `max-width: 100%`, and the viewport meta tag. Mobile-first approach starts with small screens and adds complexity for larger ones.",
    category: "CSS",
    difficulty: "EASY" as const,
    tags: ["css", "responsive", "mobile-first"],
  },
  {
    questionText: "What are React props and state? How do they differ?",
    idealAnswer: "Props are read-only data passed from parent to child components, like function arguments. State is mutable data managed within a component using `useState`. Props flow down (unidirectional), while state is local. When state changes, the component re-renders. Props should not be mutated by the receiving component.",
    category: "React",
    difficulty: "EASY" as const,
    tags: ["react", "props", "state"],
  },
  {
    questionText: "What is CSS Flexbox and when would you use it?",
    idealAnswer: "Flexbox is a one-dimensional layout model for distributing space along a row or column. Use it for aligning items, centering content, creating navigation bars, or distributing space in card layouts. Key properties: `display: flex`, `justify-content`, `align-items`, `flex-direction`, `flex-wrap`, and `gap`.",
    category: "CSS",
    difficulty: "EASY" as const,
    tags: ["css", "flexbox", "layout"],
  },
  {
    questionText: "What is event bubbling in the DOM?",
    idealAnswer: "Event bubbling is when an event triggered on a child element propagates upward through its parent elements to the document root. For example, clicking a button inside a div triggers the click handler on both. You can stop it with `event.stopPropagation()` or use event delegation by attaching a single handler to a parent.",
    category: "JavaScript",
    difficulty: "EASY" as const,
    tags: ["javascript", "dom", "events"],
  },
  {
    questionText: "What is the purpose of the `key` prop in React lists?",
    idealAnswer: "The `key` prop helps React identify which items changed, were added, or removed during reconciliation. It should be a stable, unique identifier (like an ID), not an array index. Without proper keys, React may incorrectly reuse DOM nodes, causing bugs with component state.",
    category: "React",
    difficulty: "EASY" as const,
    tags: ["react", "lists", "reconciliation"],
  },
  {
    questionText: "What is TypeScript and why use it in frontend development?",
    idealAnswer: "TypeScript is a typed superset of JavaScript that compiles to plain JS. It adds static type checking, interfaces, enums, and generics. Benefits include catching bugs at compile time, better IDE autocomplete and refactoring, self-documenting code, and improved team collaboration on large codebases.",
    category: "TypeScript",
    difficulty: "EASY" as const,
    tags: ["typescript", "types", "tooling"],
  },
  {
    questionText: "What is the difference between `null` and `undefined` in JavaScript?",
    idealAnswer: "`undefined` means a variable was declared but not assigned a value — it's the default. `null` is an intentional assignment indicating 'no value'. `typeof undefined` is 'undefined', while `typeof null` is 'object' (a historical bug). Use `null` to explicitly indicate absence of a value.",
    category: "JavaScript",
    difficulty: "EASY" as const,
    tags: ["javascript", "types", "fundamentals"],
  },
  {
    questionText: "What are CSS Grid's key advantages over Flexbox?",
    idealAnswer: "CSS Grid is two-dimensional (rows and columns simultaneously), while Flexbox is one-dimensional. Grid excels at page-level layouts, complex grid structures, and overlapping items. Use Grid for 2D layouts like dashboards and page templates; use Flexbox for 1D alignment within components.",
    category: "CSS",
    difficulty: "EASY" as const,
    tags: ["css", "grid", "layout"],
  },
  {
    questionText: "What is a closure in JavaScript?",
    idealAnswer: "A closure is a function that remembers variables from its outer (enclosing) scope even after the outer function has returned. This enables data privacy, function factories, and callbacks that retain access to their creation context. Example: a counter function that maintains a private count variable.",
    category: "JavaScript",
    difficulty: "EASY" as const,
    tags: ["javascript", "closures", "scope"],
  },
  {
    questionText: "What is JSX in React?",
    idealAnswer: "JSX is a syntax extension that lets you write HTML-like markup inside JavaScript. It gets compiled to `React.createElement()` calls by Babel/SWC. JSX allows embedding expressions with `{}`, requires `className` instead of `class`, and every tag must be closed. It makes component templates more readable.",
    category: "React",
    difficulty: "EASY" as const,
    tags: ["react", "jsx", "syntax"],
  },
  {
    questionText: "What is the `useEffect` hook used for?",
    idealAnswer: "`useEffect` runs side effects in function components — data fetching, subscriptions, DOM manipulation, or timers. It runs after render. The dependency array controls when it re-runs: empty array means once on mount, specific deps mean on those changes, no array means every render. Return a cleanup function for subscriptions/timers.",
    category: "React",
    difficulty: "EASY" as const,
    tags: ["react", "hooks", "useEffect"],
  },
  {
    questionText: "What is the difference between inline, block, and inline-block elements?",
    idealAnswer: "Block elements (`div`, `p`, `h1`) take full width and start on a new line. Inline elements (`span`, `a`, `strong`) flow within text and don't accept width/height. Inline-block elements flow inline but accept width, height, margin, and padding — useful for buttons or badges.",
    category: "CSS",
    difficulty: "EASY" as const,
    tags: ["css", "display", "layout"],
  },
  {
    questionText: "What are template literals in JavaScript?",
    idealAnswer: "Template literals use backticks and allow embedded expressions with `${expression}`, multi-line strings without escape characters, and tagged templates for custom processing. They're cleaner than string concatenation: `` `Hello ${name}` `` vs `'Hello ' + name`.",
    category: "JavaScript",
    difficulty: "EASY" as const,
    tags: ["javascript", "es6", "strings"],
  },
  {
    questionText: "What is CORS and why does it exist?",
    idealAnswer: "Cross-Origin Resource Sharing (CORS) is a browser security mechanism that restricts web pages from making requests to a different domain. It prevents malicious sites from reading sensitive data from other origins. The server controls access via headers like `Access-Control-Allow-Origin`. Preflight OPTIONS requests check permissions before actual requests.",
    category: "Web APIs",
    difficulty: "EASY" as const,
    tags: ["cors", "security", "http"],
  },
  {
    questionText: "What is the purpose of `aria` attributes in HTML?",
    idealAnswer: "ARIA (Accessible Rich Internet Applications) attributes provide semantic information to assistive technologies like screen readers. Examples: `aria-label` provides text labels, `aria-hidden` hides decorative elements, `aria-expanded` indicates toggle state. Use them to enhance accessibility when semantic HTML alone is insufficient.",
    category: "HTML",
    difficulty: "EASY" as const,
    tags: ["html", "accessibility", "aria"],
  },
  {
    questionText: "What is destructuring in JavaScript?",
    idealAnswer: "Destructuring extracts values from arrays or properties from objects into distinct variables. Array: `const [a, b] = [1, 2]`. Object: `const { name, age } = person`. It supports default values, renaming (`{ name: userName }`), nested destructuring, and rest patterns (`...rest`). Widely used in React for props and hooks.",
    category: "JavaScript",
    difficulty: "EASY" as const,
    tags: ["javascript", "es6", "destructuring"],
  },
  {
    questionText: "What is localStorage vs sessionStorage?",
    idealAnswer: "Both are Web Storage APIs storing key-value string pairs. `localStorage` persists until explicitly cleared (survives browser close). `sessionStorage` clears when the tab/window closes. Both have ~5MB limit per origin. Neither should store sensitive data as they're accessible via JavaScript (XSS vulnerable).",
    category: "Web APIs",
    difficulty: "EASY" as const,
    tags: ["web-storage", "browser", "state"],
  },
  {
    questionText: "What is the spread operator (`...`) used for?",
    idealAnswer: "The spread operator expands iterables into individual elements. Uses: copying arrays/objects (`[...arr]`, `{...obj}`), merging (`{...a, ...b}`), passing array items as function arguments (`fn(...args)`), and collecting remaining items with rest syntax. It creates shallow copies, not deep clones.",
    category: "JavaScript",
    difficulty: "EASY" as const,
    tags: ["javascript", "es6", "spread"],
  },
  {
    questionText: "What is npm and what does `package.json` do?",
    idealAnswer: "npm is Node's package manager for installing and managing JavaScript dependencies. `package.json` defines the project's metadata, scripts, dependencies, and devDependencies. `package-lock.json` locks exact versions for reproducible installs. Key commands: `npm install`, `npm run <script>`, `npm update`.",
    category: "Tooling",
    difficulty: "EASY" as const,
    tags: ["npm", "tooling", "dependencies"],
  },
  {
    questionText: "What is the difference between `margin` and `padding` in CSS?",
    idealAnswer: "Padding is the space between content and its border (inside the element), while margin is the space outside the border (between elements). Padding is included in the background color area; margin is transparent. Vertical margins collapse (the larger wins); padding never collapses.",
    category: "CSS",
    difficulty: "EASY" as const,
    tags: ["css", "box-model", "spacing"],
  },
  {
    questionText: "What are Promises in JavaScript?",
    idealAnswer: "A Promise represents a value that may be available now, later, or never. It has three states: pending, fulfilled, or rejected. Use `.then()` for success, `.catch()` for errors, `.finally()` for cleanup. `async/await` is syntactic sugar over Promises that makes async code read like synchronous code.",
    category: "JavaScript",
    difficulty: "EASY" as const,
    tags: ["javascript", "promises", "async"],
  },
  {
    questionText: "What is the `z-index` property and how does stacking context work?",
    idealAnswer: "`z-index` controls the stacking order of positioned elements (elements with `position` other than `static`). Higher values appear on top. A stacking context is created by elements with `z-index` on positioned elements, `opacity < 1`, `transform`, or `filter`. `z-index` only competes within the same stacking context.",
    category: "CSS",
    difficulty: "EASY" as const,
    tags: ["css", "z-index", "stacking"],
  },
  {
    questionText: "What is the `map()` array method and how is it used in React?",
    idealAnswer: "`map()` creates a new array by transforming each element with a callback function. In React, it's the standard way to render lists: `{items.map(item => <li key={item.id}>{item.name}</li>)}`. It returns a new array without mutating the original, which aligns with React's immutability principles.",
    category: "JavaScript",
    difficulty: "EASY" as const,
    tags: ["javascript", "arrays", "react"],
  },
  {
    questionText: "What are media queries in CSS?",
    idealAnswer: "Media queries apply CSS rules conditionally based on device characteristics like viewport width, height, orientation, or color scheme. Example: `@media (max-width: 768px) { ... }` targets screens 768px or narrower. They're the foundation of responsive design, typically used with a mobile-first approach (min-width breakpoints).",
    category: "CSS",
    difficulty: "EASY" as const,
    tags: ["css", "media-queries", "responsive"],
  },
  {
    questionText: "What is the difference between `fetch` and `XMLHttpRequest`?",
    idealAnswer: "`fetch` is the modern Promise-based API for HTTP requests, cleaner than callback-based `XMLHttpRequest`. Fetch doesn't reject on HTTP errors (only network failures), doesn't send cookies by default, and supports streaming. However, fetch lacks built-in timeout, upload progress events, and request cancellation (use `AbortController` for that).",
    category: "Web APIs",
    difficulty: "EASY" as const,
    tags: ["javascript", "fetch", "http"],
  },

  // ===== MEDIUM (40 questions) =====
  {
    questionText: "Explain React's reconciliation algorithm and how it optimizes rendering.",
    idealAnswer: "React's reconciliation (diffing) compares the new Virtual DOM tree with the previous one. It uses two heuristics: elements of different types produce different trees (full rebuild), and keys identify stable elements across renders. It diffs top-down, same level only — O(n) complexity instead of O(n³). This is why keys on lists matter for performance.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "reconciliation", "performance"],
  },
  {
    questionText: "What are React hooks rules and why do they exist?",
    idealAnswer: "Two rules: (1) Only call hooks at the top level — never inside loops, conditions, or nested functions. (2) Only call hooks from React function components or custom hooks. These rules exist because React relies on call order to associate hook state with components. Violating them causes state mismatches. The `eslint-plugin-react-hooks` enforces these.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "hooks", "rules"],
  },
  {
    questionText: "How does CSS specificity work? How do you calculate it?",
    idealAnswer: "Specificity determines which CSS rules apply when multiple rules target the same element. Calculated as (inline, IDs, classes/attributes/pseudo-classes, elements/pseudo-elements). `#header .nav a` = (0,1,1,1). Higher specificity wins; equal specificity uses last-declared rule. `!important` overrides everything (avoid it). Specificity is not a base-10 number — 11 classes don't beat 1 ID.",
    category: "CSS",
    difficulty: "MEDIUM" as const,
    tags: ["css", "specificity", "selectors"],
  },
  {
    questionText: "What is the difference between `useMemo` and `useCallback`?",
    idealAnswer: "`useMemo` memoizes a computed value, re-computing only when dependencies change — useful for expensive calculations. `useCallback` memoizes a function reference — useful for preventing unnecessary re-renders of child components that use `React.memo`. `useCallback(fn, deps)` is equivalent to `useMemo(() => fn, deps)`. Don't overuse them — they add complexity and memory overhead.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "hooks", "memoization"],
  },
  {
    questionText: "Explain the event loop in JavaScript. How do microtasks and macrotasks differ?",
    idealAnswer: "The event loop processes tasks from the call stack, then checks the microtask queue (Promises, MutationObserver), then the macrotask queue (setTimeout, setInterval, I/O). All microtasks run before the next macrotask. So `Promise.resolve().then(...)` executes before `setTimeout(..., 0)`. This explains why Promise callbacks are prioritized over timers.",
    category: "JavaScript",
    difficulty: "MEDIUM" as const,
    tags: ["javascript", "event-loop", "async"],
  },
  {
    questionText: "What is the Context API in React and when should you use it instead of prop drilling?",
    idealAnswer: "Context provides a way to pass data through the component tree without prop drilling. Create with `createContext`, provide with `<Context.Provider value={...}>`, consume with `useContext`. Use it for global concerns: theme, locale, auth state. Avoid for frequently changing data (causes all consumers to re-render). For complex state, consider Zustand or Redux.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "context", "state-management"],
  },
  {
    questionText: "How would you optimize a React application's performance?",
    idealAnswer: "Key strategies: (1) Use `React.memo` for components with stable props, (2) `useMemo`/`useCallback` for expensive computations, (3) Code splitting with `React.lazy` and `Suspense`, (4) Virtualize long lists with react-window, (5) Avoid unnecessary state lifts, (6) Use the React DevTools Profiler to find bottleneck components, (7) Debounce rapid state updates like search inputs.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "performance", "optimization"],
  },
  {
    questionText: "What is the difference between server-side rendering (SSR) and client-side rendering (CSR)?",
    idealAnswer: "CSR renders entirely in the browser — fast navigation but slow initial load, poor SEO. SSR generates HTML on the server — faster First Contentful Paint, better SEO, but higher server cost and full page reloads. Modern frameworks like Next.js offer hybrid approaches: SSR for initial load, then CSR for navigation. Static Site Generation (SSG) pre-builds pages at build time for best performance.",
    category: "Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["ssr", "csr", "nextjs", "rendering"],
  },
  {
    questionText: "Explain TypeScript generics with a practical example.",
    idealAnswer: "Generics allow creating reusable components that work with multiple types while maintaining type safety. Example: `function getFirst<T>(arr: T[]): T | undefined { return arr[0]; }` — works with any array type and returns the correct type. Common uses: API response wrappers (`ApiResponse<T>`), React component props, utility types like `Partial<T>` and `Pick<T, K>`.",
    category: "TypeScript",
    difficulty: "MEDIUM" as const,
    tags: ["typescript", "generics", "types"],
  },
  {
    questionText: "What are Web Vitals and why are they important?",
    idealAnswer: "Core Web Vitals are Google's metrics for user experience: LCP (Largest Contentful Paint, loading speed < 2.5s), FID/INP (First Input Delay / Interaction to Next Paint, interactivity < 100ms), and CLS (Cumulative Layout Shift, visual stability < 0.1). They affect SEO rankings and user satisfaction. Measure with Lighthouse, Chrome DevTools, or web-vitals library.",
    category: "Performance",
    difficulty: "MEDIUM" as const,
    tags: ["web-vitals", "performance", "seo"],
  },
  {
    questionText: "How does CSS-in-JS work and what are the trade-offs?",
    idealAnswer: "CSS-in-JS libraries (styled-components, Emotion) write CSS in JavaScript, generating unique class names at runtime. Pros: scoped styles, dynamic styling based on props, co-located code, no class name conflicts. Cons: runtime overhead, larger bundle size, harder to cache, SSR complexity. Alternatives: CSS Modules (scoping without runtime), Tailwind CSS (utility-first), or vanilla CSS with BEM naming.",
    category: "CSS",
    difficulty: "MEDIUM" as const,
    tags: ["css-in-js", "styled-components", "styling"],
  },
  {
    questionText: "What is a service worker and how does it enable PWAs?",
    idealAnswer: "A service worker is a background script that intercepts network requests, enabling offline caching, push notifications, and background sync. It runs on a separate thread, can't access the DOM directly, and requires HTTPS. For PWAs, it caches assets using the Cache API so the app works offline. Lifecycle: install → activate → fetch events.",
    category: "Web APIs",
    difficulty: "MEDIUM" as const,
    tags: ["service-worker", "pwa", "caching"],
  },
  {
    questionText: "Explain the difference between controlled and uncontrolled components in React.",
    idealAnswer: "Controlled components have their value managed by React state — every change goes through `onChange` handler and `setState`. Uncontrolled components manage their own state in the DOM, accessed via `ref`. Controlled components give you full control (validation, formatting) but require more code. Uncontrolled are simpler for basic forms. React Hook Form uses uncontrolled components with refs for performance.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "forms", "controlled-components"],
  },
  {
    questionText: "What is tree shaking and how does it reduce bundle size?",
    idealAnswer: "Tree shaking is dead code elimination that removes unused exports from the final bundle. It relies on ES modules' static structure (import/export) to determine what's used. Webpack and Rollup perform tree shaking during bundling. To enable it: use ES module syntax, mark packages as `sideEffects: false` in package.json, and avoid importing entire libraries (`import { map } from 'lodash-es'` not `import _ from 'lodash'`).",
    category: "Tooling",
    difficulty: "MEDIUM" as const,
    tags: ["tree-shaking", "webpack", "bundling"],
  },
  {
    questionText: "How does `useReducer` compare to `useState` for state management?",
    idealAnswer: "`useState` is simple for independent state values. `useReducer` is better for complex state logic with multiple sub-values, when the next state depends on the previous, or when you want to centralize state transitions. It follows Redux pattern: `dispatch(action)` → `reducer(state, action)` → new state. Makes state transitions predictable and testable.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "hooks", "state-management"],
  },
  {
    questionText: "What is XSS and how do you prevent it in frontend applications?",
    idealAnswer: "Cross-Site Scripting (XSS) injects malicious scripts into web pages. Types: Stored (persisted in DB), Reflected (in URL params), DOM-based (client-side manipulation). Prevention: sanitize user input, use `textContent` instead of `innerHTML`, React auto-escapes JSX (but `dangerouslySetInnerHTML` bypasses this), use Content-Security-Policy headers, and validate/escape on both client and server.",
    category: "Security",
    difficulty: "MEDIUM" as const,
    tags: ["security", "xss", "sanitization"],
  },
  {
    questionText: "Explain the Next.js App Router and how it differs from the Pages Router.",
    idealAnswer: "App Router (Next.js 13+) uses the `app/` directory with file-based routing using folders. Key differences: React Server Components by default, layouts with `layout.tsx` that persist across navigations, loading states with `loading.tsx`, error boundaries with `error.tsx`, and streaming SSR. Pages Router uses `pages/` directory, `getServerSideProps`/`getStaticProps`, and all components are client components by default.",
    category: "Next.js",
    difficulty: "MEDIUM" as const,
    tags: ["nextjs", "app-router", "routing"],
  },
  {
    questionText: "What is debouncing vs throttling? When would you use each?",
    idealAnswer: "Debouncing delays execution until after a pause in events (e.g., wait 300ms after the user stops typing to search). Throttling limits execution to at most once per time interval (e.g., handle scroll events at most every 100ms). Use debounce for search inputs, form validation, window resize. Use throttle for scroll handlers, mouse move tracking, rate-limited API calls.",
    category: "JavaScript",
    difficulty: "MEDIUM" as const,
    tags: ["javascript", "debounce", "throttle", "performance"],
  },
  {
    questionText: "How do CSS animations differ from JavaScript animations? When would you choose each?",
    idealAnswer: "CSS animations (transitions, @keyframes) are GPU-accelerated, performant for simple property changes (transform, opacity), and declared declaratively. JS animations (requestAnimationFrame, GSAP, Framer Motion) offer more control: complex sequences, physics-based motion, scroll-driven effects, and dynamic values. Prefer CSS for simple hover/transitions, JS for complex interactive animations.",
    category: "CSS",
    difficulty: "MEDIUM" as const,
    tags: ["css", "animations", "performance"],
  },
  {
    questionText: "What is React.memo and when should you use it?",
    idealAnswer: "`React.memo` is a higher-order component that skips re-rendering if props haven't changed (shallow comparison). Use it for components that render often with the same props, especially in lists or below frequently-updating parents. Don't overuse it — the comparison itself has cost, and it's unnecessary if the component is cheap to render or props change every time.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "memo", "performance"],
  },
  {
    questionText: "Explain the concept of hydration in server-rendered React applications.",
    idealAnswer: "Hydration is the process where client-side React attaches event listeners and state to server-rendered HTML, making it interactive. The server sends static HTML (fast initial render), then React 'hydrates' it by reconciling the Virtual DOM with the existing DOM. Mismatches between server and client HTML cause hydration errors. Next.js handles this automatically.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "ssr", "hydration"],
  },
  {
    questionText: "What is the `Intersection Observer` API and how is it useful?",
    idealAnswer: "Intersection Observer asynchronously observes changes in the intersection of a target element with an ancestor or viewport. Use cases: lazy loading images, infinite scroll, analytics visibility tracking, and triggering animations on scroll. It's more performant than scroll event listeners because it runs off the main thread and uses thresholds instead of continuous polling.",
    category: "Web APIs",
    difficulty: "MEDIUM" as const,
    tags: ["intersection-observer", "performance", "lazy-loading"],
  },
  {
    questionText: "How do you handle error boundaries in React?",
    idealAnswer: "Error boundaries are class components that catch JavaScript errors in their child component tree during rendering, lifecycle methods, and constructors. Implement `static getDerivedStateFromError()` for fallback UI and `componentDidCatch()` for logging. They don't catch errors in event handlers, async code, or SSR. In Next.js App Router, use `error.tsx` files for declarative error handling.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "error-boundaries", "error-handling"],
  },
  {
    questionText: "What are TypeScript utility types? Name and explain five.",
    idealAnswer: "Common utility types: `Partial<T>` makes all properties optional, `Required<T>` makes all required, `Pick<T, K>` selects specific properties, `Omit<T, K>` excludes properties, `Record<K, V>` creates an object type with keys K and values V. Also useful: `Readonly<T>`, `ReturnType<T>`, `Parameters<T>`, and `Extract<T, U>`. They reduce boilerplate and improve type reuse.",
    category: "TypeScript",
    difficulty: "MEDIUM" as const,
    tags: ["typescript", "utility-types", "generics"],
  },
  {
    questionText: "How would you implement code splitting in a React application?",
    idealAnswer: "Code splitting loads code on demand instead of upfront. Methods: (1) `React.lazy()` with `Suspense` for component-level splitting, (2) Dynamic `import()` for any module, (3) Route-based splitting (Next.js does this automatically per page). Webpack splits at dynamic import boundaries. This reduces initial bundle size and improves loading performance for large applications.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "code-splitting", "performance"],
  },
  {
    questionText: "What is the difference between `position: relative`, `absolute`, `fixed`, and `sticky`?",
    idealAnswer: "`relative` positions relative to normal position (still in flow). `absolute` positions relative to the nearest positioned ancestor (removed from flow). `fixed` positions relative to the viewport (removed from flow, stays on scroll). `sticky` behaves as relative until a scroll threshold, then becomes fixed. Each creates a new stacking context.",
    category: "CSS",
    difficulty: "MEDIUM" as const,
    tags: ["css", "positioning", "layout"],
  },
  {
    questionText: "Explain how React Server Components work in Next.js 14.",
    idealAnswer: "Server Components render on the server and send only the HTML to the client — no JavaScript bundle for that component. They can directly access databases, file systems, and secrets. They can't use hooks, event handlers, or browser APIs. Use `'use client'` directive to opt into Client Components when you need interactivity. This reduces bundle size and enables streaming server rendering.",
    category: "Next.js",
    difficulty: "MEDIUM" as const,
    tags: ["nextjs", "server-components", "rsc"],
  },
  {
    questionText: "How do you manage global state in a React application without Redux?",
    idealAnswer: "Alternatives: (1) React Context + useReducer for simple global state, (2) Zustand — minimal, no boilerplate, works outside React, (3) Jotai — atomic state model, (4) React Query/TanStack Query for server state management. Choose based on needs: Zustand for simplicity, Jotai for fine-grained reactivity, React Query for API data that needs caching and synchronization.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "state-management", "zustand"],
  },
  {
    questionText: "What is the purpose of `React.StrictMode`?",
    idealAnswer: "`StrictMode` is a development-only tool that highlights potential problems. It double-invokes render functions and effects to detect side effects, warns about deprecated lifecycle methods, and checks for legacy patterns. In React 18, it also remounts components to prepare for Offscreen features. It doesn't affect production builds and wraps sections of the component tree.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "strict-mode", "development"],
  },
  {
    questionText: "How do CSS custom properties (variables) work and what are their advantages?",
    idealAnswer: "CSS variables are declared with `--name: value` and used with `var(--name, fallback)`. They cascade and inherit like regular properties, can be scoped to selectors, and changed dynamically via JavaScript or media queries. Advantages over preprocessor variables: they're live (change at runtime), can be themed with class toggles, and work with the cascade. Perfect for design systems and dark mode.",
    category: "CSS",
    difficulty: "MEDIUM" as const,
    tags: ["css", "custom-properties", "theming"],
  },
  {
    questionText: "What is Webpack and how does it work at a high level?",
    idealAnswer: "Webpack is a module bundler that takes modules with dependencies and generates static assets. It starts from entry points, builds a dependency graph following imports, applies loaders to transform files (Babel for JS, css-loader for CSS), and uses plugins for optimization (minification, tree-shaking). Output is one or more bundles. Modern alternatives: Vite (ESBuild + Rollup), Turbopack, and esbuild.",
    category: "Tooling",
    difficulty: "MEDIUM" as const,
    tags: ["webpack", "bundling", "tooling"],
  },
  {
    questionText: "How do you handle authentication state in a Next.js application?",
    idealAnswer: "Common approaches: (1) JWT in httpOnly cookies with middleware for route protection, (2) NextAuth.js for OAuth providers, (3) Server-side session validation in Server Components. Store auth state client-side with Zustand/Context. Protect API routes in `middleware.ts` by checking the token. Server Components can directly validate sessions, while Client Components check auth state and redirect.",
    category: "Next.js",
    difficulty: "MEDIUM" as const,
    tags: ["nextjs", "authentication", "security"],
  },
  {
    questionText: "Explain the concept of immutability in React state management.",
    idealAnswer: "React detects state changes via reference comparison, not deep equality. Mutating objects/arrays in place doesn't trigger re-renders. Always create new references: use spread (`{...obj, key: newVal}`), `map`/`filter` for arrays, or libraries like Immer. This enables efficient change detection, predictable rendering, time-travel debugging, and prevents stale closure bugs.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "immutability", "state"],
  },
  {
    questionText: "What is a CSS preprocessor? Compare Sass and PostCSS.",
    idealAnswer: "CSS preprocessors add features like variables, nesting, mixins, and functions to CSS. Sass (SCSS syntax) compiles to CSS with features like `@mixin`, `@extend`, and math operations. PostCSS is a JS tool that transforms CSS with plugins — it can do autoprefixing, nesting, and future CSS syntax. PostCSS is more flexible but requires plugin configuration. Tailwind CSS uses PostCSS under the hood.",
    category: "CSS",
    difficulty: "MEDIUM" as const,
    tags: ["css", "sass", "postcss"],
  },
  {
    questionText: "What are React portals and when would you use them?",
    idealAnswer: "Portals render children into a DOM node outside the parent component's DOM hierarchy, while maintaining React's event bubbling. Created with `ReactDOM.createPortal(child, container)`. Use cases: modals/dialogs (render at document body to avoid z-index and overflow issues), tooltips, dropdown menus, and toast notifications. Events still bubble through the React tree, not the DOM tree.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "portals", "dom"],
  },
  {
    questionText: "How do you write accessible forms in HTML/React?",
    idealAnswer: "Key practices: associate labels with inputs via `htmlFor`/`id`, use `fieldset` and `legend` for groups, add `aria-describedby` for helper text, set `aria-invalid` and `aria-errormessage` for errors, use `required` attribute, ensure keyboard navigation works, provide visible focus indicators, and test with screen readers. React Hook Form and Radix UI provide accessible primitives.",
    category: "Accessibility",
    difficulty: "MEDIUM" as const,
    tags: ["accessibility", "forms", "html"],
  },
  {
    questionText: "What is the `Suspense` component in React and how is it used?",
    idealAnswer: "`Suspense` shows a fallback UI while children are loading. Uses: (1) Code splitting with `React.lazy`, (2) Data fetching in RSC (React Server Components throw promises that Suspense catches), (3) Streaming SSR in Next.js. Wrap lazy components: `<Suspense fallback={<Spinner />}><LazyComponent /></Suspense>`. Multiple Suspense boundaries give granular loading states.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "suspense", "loading"],
  },
  {
    questionText: "How do you implement dark mode in a web application?",
    idealAnswer: "Approaches: (1) CSS custom properties with a class toggle (`.dark` on `<html>`), (2) `prefers-color-scheme` media query for OS preference, (3) Tailwind's `dark:` variant. Store preference in localStorage, default to OS setting. Use `<meta name='color-scheme'>` for native form controls. Transition smoothly with `transition: background-color 0.3s`. Apply theme in layout to avoid flash of wrong theme.",
    category: "CSS",
    difficulty: "MEDIUM" as const,
    tags: ["css", "dark-mode", "theming"],
  },
  {
    questionText: "What are custom hooks in React? Give an example of when you'd create one.",
    idealAnswer: "Custom hooks are functions starting with `use` that encapsulate reusable stateful logic. They can call other hooks. Example: `useDebounce(value, delay)` returns a debounced value for search inputs. Other examples: `useFetch(url)` for data fetching, `useLocalStorage(key)` for persisted state, `useMediaQuery(query)` for responsive logic. They separate concerns and enable code reuse without render props or HOCs.",
    category: "React",
    difficulty: "MEDIUM" as const,
    tags: ["react", "custom-hooks", "reuse"],
  },
  {
    questionText: "Explain the CSS `container queries` feature and how it differs from media queries.",
    idealAnswer: "Container queries let components respond to their container's size, not the viewport. Declare with `container-type: inline-size` on the parent, then query with `@container (min-width: 400px) { ... }`. This makes components truly reusable — a card component can adapt whether it's in a sidebar or main content. Media queries only check viewport, so the same component can't adapt to different container sizes.",
    category: "CSS",
    difficulty: "MEDIUM" as const,
    tags: ["css", "container-queries", "responsive"],
  },

  // ===== HARD (30 questions) =====
  {
    questionText: "How would you architect a micro-frontend application? What are the trade-offs?",
    idealAnswer: "Micro-frontends split a frontend into independently deployable modules owned by different teams. Approaches: (1) Module Federation (Webpack 5) for runtime composition, (2) iframe isolation, (3) Web Components, (4) server-side composition. Trade-offs: team autonomy and independent deployments vs. increased complexity, bundle duplication, inconsistent UX, shared state challenges, and harder debugging across boundaries.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["micro-frontends", "architecture", "module-federation"],
  },
  {
    questionText: "Explain React's Concurrent Mode and how it improves user experience.",
    idealAnswer: "Concurrent Mode lets React prepare multiple versions of the UI simultaneously without blocking the main thread. Features: (1) `startTransition` marks non-urgent updates so urgent ones (typing) aren't blocked, (2) `useDeferredValue` defers expensive re-renders, (3) Suspense enables streaming SSR. React can interrupt rendering to handle higher-priority updates, keeping the UI responsive during heavy computations.",
    category: "React",
    difficulty: "HARD" as const,
    tags: ["react", "concurrent-mode", "performance"],
  },
  {
    questionText: "How would you design a real-time collaborative text editor in the browser?",
    idealAnswer: "Use CRDTs (Conflict-free Replicated Data Types) like Yjs or Automerge for conflict resolution without a central server. Connect via WebSocket for real-time sync. Key challenges: cursor positioning after remote edits, undo/redo per user, offline support with eventual consistency, and rich text formatting. Alternative: Operational Transform (used by Google Docs) requires a central server but is more established.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["real-time", "crdt", "websocket", "collaboration"],
  },
  {
    questionText: "What is the JavaScript engine's hidden class mechanism and how does it affect performance?",
    idealAnswer: "V8 creates hidden classes (shapes/maps) for objects to optimize property access. Objects with the same property order share hidden classes, enabling fast inline caching. Adding properties in different orders creates different hidden classes, degrading performance. Best practices: initialize all properties in constructors in consistent order, avoid deleting properties or adding them dynamically after creation.",
    category: "JavaScript",
    difficulty: "HARD" as const,
    tags: ["javascript", "v8", "performance", "hidden-classes"],
  },
  {
    questionText: "How would you implement an efficient virtual scrolling solution from scratch?",
    idealAnswer: "Virtual scrolling renders only visible items plus a buffer. Implementation: (1) Calculate visible range from scroll position and container height, (2) Render only items in that range using absolute positioning or transform, (3) Set total container height to maintain scrollbar, (4) Handle dynamic row heights with a position cache, (5) Add overscan rows for smooth scrolling. Key challenges: variable heights, keyboard navigation, and accessibility with `aria-rowcount`.",
    category: "Performance",
    difficulty: "HARD" as const,
    tags: ["virtual-scroll", "performance", "dom"],
  },
  {
    questionText: "Explain the security implications of `dangerouslySetInnerHTML` and alternatives for rich content.",
    idealAnswer: "It bypasses React's XSS protection by inserting raw HTML, enabling injection attacks if content isn't sanitized. Alternatives: (1) DOMPurify to sanitize HTML before insertion, (2) Parse HTML to an AST and render React elements (rehype-react), (3) Use a markdown renderer like react-markdown with sanitization, (4) Content Security Policy headers as defense-in-depth. Always sanitize server-side too, never trust client-only sanitization.",
    category: "Security",
    difficulty: "HARD" as const,
    tags: ["security", "xss", "react", "sanitization"],
  },
  {
    questionText: "How does React's fiber architecture work internally?",
    idealAnswer: "Fiber is React's reconciliation engine that represents the component tree as a linked list of fiber nodes. Each fiber has: type, key, child/sibling/return pointers, pendingProps, memoizedState, and effectTag. It enables incremental rendering by splitting work into units, yielding to the browser between frames. Two phases: render (interruptible, builds work-in-progress tree) and commit (synchronous, applies DOM changes).",
    category: "React",
    difficulty: "HARD" as const,
    tags: ["react", "fiber", "internals"],
  },
  {
    questionText: "Design a component library's theming system that supports multiple brands and dark mode.",
    idealAnswer: "Use CSS custom properties organized in layers: (1) primitive tokens (`--color-blue-500`), (2) semantic tokens (`--color-primary`, `--color-background`), (3) component tokens (`--button-bg`). Apply brand themes via data attributes (`data-brand='acme'`). Dark mode flips semantic tokens. Use a ThemeProvider that sets CSS variables on a root element. TypeScript enforces token usage. This separates design decisions from component implementation.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["design-system", "theming", "css-variables"],
  },
  {
    questionText: "What are the memory leak patterns in JavaScript SPAs and how do you detect and fix them?",
    idealAnswer: "Common leaks: (1) Uncleared timers/intervals, (2) Event listeners not removed on unmount, (3) Closures retaining large objects, (4) Detached DOM nodes referenced by JS, (5) Forgotten subscriptions (WebSocket, observables). Detect with Chrome DevTools Memory tab: take heap snapshots, compare allocations, find retainer chains. Fix: cleanup in `useEffect` return, use `AbortController` for fetch, WeakRef/WeakMap for caches.",
    category: "JavaScript",
    difficulty: "HARD" as const,
    tags: ["javascript", "memory-leaks", "debugging"],
  },
  {
    questionText: "How would you implement a robust image optimization pipeline for a web application?",
    idealAnswer: "Pipeline: (1) Accept uploads, validate dimensions/format, (2) Generate multiple sizes (thumbnail, medium, large) with sharp, (3) Convert to modern formats (WebP, AVIF) with fallbacks, (4) Lazy load with `loading='lazy'` and Intersection Observer, (5) Use `srcset` and `sizes` for responsive images, (6) Serve via CDN with cache headers, (7) Blur hash placeholders for perceived performance. Next.js `Image` component handles most of this automatically.",
    category: "Performance",
    difficulty: "HARD" as const,
    tags: ["images", "performance", "optimization"],
  },
  {
    questionText: "Explain how to implement a custom React renderer (like React Native or React Three Fiber).",
    idealAnswer: "Use `react-reconciler` package which exposes the fiber reconciler. Implement a host config with methods: `createInstance`, `appendChild`, `removeChild`, `commitUpdate`, `prepareUpdate`, etc. The reconciler handles diffing and scheduling; your host config translates operations to the target platform (DOM, canvas, terminal, native). React Three Fiber maps React elements to three.js scene graph operations this way.",
    category: "React",
    difficulty: "HARD" as const,
    tags: ["react", "renderer", "internals"],
  },
  {
    questionText: "What strategies would you use to reduce JavaScript bundle size in a large application?",
    idealAnswer: "Strategies: (1) Code splitting and lazy loading (route-level and component-level), (2) Tree shaking with ES modules, (3) Replace heavy libraries (moment.js → date-fns, lodash → lodash-es), (4) Dynamic imports for rarely-used features, (5) Analyze with webpack-bundle-analyzer, (6) Externalize large deps to CDN, (7) Compression (gzip/brotli), (8) Module/nomodule pattern for modern browsers. Target: main bundle under 200KB gzipped.",
    category: "Performance",
    difficulty: "HARD" as const,
    tags: ["bundling", "performance", "optimization"],
  },
  {
    questionText: "How do you handle state synchronization between browser tabs?",
    idealAnswer: "Methods: (1) `BroadcastChannel` API for same-origin tab communication, (2) `storage` event on localStorage changes, (3) SharedWorker for shared state processing, (4) Service Worker with `postMessage`, (5) IndexedDB with polling or locks API. Use case: auth state sync (logout in one tab logs out all tabs), cart updates, real-time notifications. BroadcastChannel is simplest; SharedWorker for complex state.",
    category: "Web APIs",
    difficulty: "HARD" as const,
    tags: ["browser", "state-sync", "broadcast-channel"],
  },
  {
    questionText: "How would you design an offline-first web application architecture?",
    idealAnswer: "Architecture: (1) Service Worker with Cache API for static assets and API responses, (2) IndexedDB for structured data storage via Dexie.js, (3) Background Sync API for queuing failed requests, (4) Optimistic UI updates with rollback on sync failure, (5) Conflict resolution strategy (last-write-wins or CRDT), (6) Version management for cached resources, (7) Network status detection with online/offline events. Progressive enhancement: works online first, gracefully degrades offline.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["offline-first", "pwa", "service-worker"],
  },
  {
    questionText: "Explain how to implement accessible drag and drop with keyboard support.",
    idealAnswer: "Implementation: (1) Use `aria-grabbed` and `aria-dropeffect` for ARIA semantics, (2) Keyboard: Space/Enter to pick up, arrow keys to move, Space/Enter to drop, Escape to cancel, (3) Announce state changes via `aria-live` regions, (4) Provide visual and auditory feedback, (5) Use `role='listbox'` with `aria-selected` as alternative. Libraries: dnd-kit is accessibility-focused. Ensure all drag operations have keyboard equivalents — many users can't use a mouse.",
    category: "Accessibility",
    difficulty: "HARD" as const,
    tags: ["accessibility", "drag-drop", "keyboard"],
  },
  {
    questionText: "What are the rendering patterns in Next.js 14 and when would you use each?",
    idealAnswer: "Patterns: (1) Static (SSG) — build-time rendering for content that rarely changes, (2) Dynamic (SSR) — per-request rendering for personalized/real-time data, (3) ISR (Incremental Static Regeneration) — static with background revalidation, (4) Streaming — progressive SSR with Suspense boundaries, (5) Partial Prerendering — static shell with dynamic holes. Choose based on data freshness needs, personalization, and performance requirements.",
    category: "Next.js",
    difficulty: "HARD" as const,
    tags: ["nextjs", "rendering", "ssr", "ssg"],
  },
  {
    questionText: "How do you implement proper internationalization (i18n) in a React application?",
    idealAnswer: "Use react-intl or next-intl: (1) Extract strings to message catalogs (JSON per locale), (2) Use `IntlProvider` with locale detection (browser, URL, cookie), (3) Handle pluralization, date/number formatting, and RTL layouts, (4) Dynamic locale loading to avoid bundling all translations, (5) Server-side locale negotiation with `Accept-Language` header, (6) URL-based routing (`/en/about`, `/fr/about`). Challenges: string concatenation (use ICU message format), layout shifts with different text lengths.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["i18n", "internationalization", "react"],
  },
  {
    questionText: "How would you implement a design system with variant-based component APIs?",
    idealAnswer: "Use CVA (Class Variance Authority) or Stitches for variant definition: `variant`, `size`, `color` props mapped to style combinations. Structure: (1) Primitive components (Button, Input, Text) with exhaustive variants, (2) Compound components for complex patterns (Tabs, Accordion), (3) TypeScript discriminated unions for variant-dependent props, (4) Storybook for documentation, (5) Chromatic for visual regression. Distribute via npm package with tree-shakeable exports.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["design-system", "components", "cva"],
  },
  {
    questionText: "Explain the differences between Web Workers, Service Workers, and SharedWorkers.",
    idealAnswer: "Web Workers run scripts in background threads for CPU-intensive tasks, each dedicated to one page. Service Workers are event-driven proxies between app and network, enabling offline caching and push notifications — they persist across page loads and have no DOM access. SharedWorkers are shared across multiple tabs/windows of the same origin. All communicate via `postMessage`. Use Web Workers for computation, Service Workers for caching/offline, SharedWorkers for shared state.",
    category: "Web APIs",
    difficulty: "HARD" as const,
    tags: ["web-workers", "service-worker", "concurrency"],
  },
  {
    questionText: "How would you build a type-safe API layer between frontend and backend?",
    idealAnswer: "Options: (1) tRPC — end-to-end type safety with zero schema duplication, server defines procedures, client gets typed API automatically, (2) GraphQL with codegen — schema generates TypeScript types and typed hooks, (3) OpenAPI/Swagger with codegen (openapi-typescript), (4) Zod schemas shared in a monorepo package. tRPC is ideal for TypeScript monorepos, GraphQL for complex data requirements, OpenAPI for language-agnostic APIs.",
    category: "TypeScript",
    difficulty: "HARD" as const,
    tags: ["typescript", "api", "trpc", "type-safety"],
  },
  {
    questionText: "What is the Islands Architecture and how does it compare to traditional SSR?",
    idealAnswer: "Islands Architecture (Astro, Fresh) renders the page as static HTML with isolated interactive 'islands' that hydrate independently. Unlike traditional SSR (which hydrates the entire page), only interactive components ship JavaScript. Benefits: minimal JS, fast loading, progressive enhancement. Trade-offs: component communication is harder, framework-specific solutions needed, less suitable for highly interactive SPAs. Ideal for content-heavy sites with selective interactivity.",
    category: "Architecture",
    difficulty: "HARD" as const,
    tags: ["islands-architecture", "astro", "performance"],
  },
  {
    questionText: "How would you implement a complex form with dynamic fields, validation, and multi-step navigation?",
    idealAnswer: "Use React Hook Form with Zod validation: (1) Define Zod schemas per step, (2) `useForm` with `resolver: zodResolver(schema)`, (3) Store intermediate state in form context or URL params, (4) Dynamic fields with `useFieldArray`, (5) Conditional rendering based on previous answers, (6) Persist draft to localStorage, (7) Optimistic submission with error recovery. Multi-step: track step index, validate current step before advancing, allow back navigation without losing data.",
    category: "React",
    difficulty: "HARD" as const,
    tags: ["react", "forms", "validation", "react-hook-form"],
  },
  {
    questionText: "Explain how to implement a custom webpack plugin and loader.",
    idealAnswer: "Loaders transform individual files — they're functions receiving source content and returning transformed content. Example: a markdown loader that converts .md to React components. Plugins hook into webpack's compilation lifecycle using tapable hooks. Example: a plugin that generates a manifest.json. Loaders use `this.getOptions()` for config, return with `this.callback()`. Plugins implement `apply(compiler)` and tap into hooks like `compilation`, `emit`, `done`.",
    category: "Tooling",
    difficulty: "HARD" as const,
    tags: ["webpack", "plugins", "loaders"],
  },
  {
    questionText: "How do you handle layout shifts and improve CLS in complex web applications?",
    idealAnswer: "Strategies: (1) Set explicit dimensions on images/videos (`width`/`height` attributes or aspect-ratio), (2) Reserve space for dynamic content with skeleton placeholders, (3) Avoid inserting content above the fold after load, (4) Use `font-display: swap` with size-adjusted fallback fonts, (5) Preconnect to required origins, (6) Avoid FOUC by inlining critical CSS, (7) Use `content-visibility: auto` for off-screen content. Measure CLS in field data with Web Vitals library.",
    category: "Performance",
    difficulty: "HARD" as const,
    tags: ["cls", "web-vitals", "performance"],
  },
  {
    questionText: "What are the security considerations when implementing OAuth 2.0 / OIDC in a SPA?",
    idealAnswer: "SPAs can't securely store client secrets, so use PKCE (Proof Key for Code Exchange) with the authorization code flow. Store tokens in httpOnly cookies (not localStorage — XSS vulnerable). Implement: (1) State parameter to prevent CSRF, (2) Nonce for ID token replay protection, (3) Short-lived access tokens with refresh token rotation, (4) Token binding, (5) Strict redirect URI validation. Use a BFF (Backend for Frontend) pattern to keep tokens server-side.",
    category: "Security",
    difficulty: "HARD" as const,
    tags: ["security", "oauth", "authentication"],
  },
  {
    questionText: "How would you implement server-sent events (SSE) vs WebSocket for real-time updates?",
    idealAnswer: "SSE is unidirectional (server to client), uses HTTP, auto-reconnects, and works through proxies/firewalls easily. WebSocket is bidirectional, uses its own protocol, and requires manual reconnection. Choose SSE for: notifications, live feeds, progress updates (read-only streams). Choose WebSocket for: chat, collaboration, gaming (bidirectional). SSE is simpler to implement and maintain. Next.js API routes support SSE with ReadableStream.",
    category: "Web APIs",
    difficulty: "HARD" as const,
    tags: ["sse", "websocket", "real-time"],
  },
  {
    questionText: "How would you set up a comprehensive frontend testing strategy?",
    idealAnswer: "Testing pyramid: (1) Unit tests (Vitest/Jest) for utilities, hooks, reducers — fast, isolated, (2) Component tests (React Testing Library) for behavior, not implementation — render, interact, assert, (3) Integration tests for feature flows with mocked APIs (MSW), (4) E2E tests (Playwright/Cypress) for critical user journeys — login, checkout, (5) Visual regression with Chromatic/Percy. Aim for 80% coverage on business logic, test user behavior not internal state.",
    category: "Testing",
    difficulty: "HARD" as const,
    tags: ["testing", "jest", "rtl", "e2e"],
  },
  {
    questionText: "Explain how to build a performant data grid component that handles 100k+ rows.",
    idealAnswer: "Key techniques: (1) Virtualization — only render visible rows + buffer (react-virtual), (2) Fixed headers with `position: sticky`, (3) Column virtualization for wide tables, (4) Debounced sorting/filtering on worker thread, (5) Server-side pagination/filtering for large datasets, (6) `requestAnimationFrame` for smooth scroll, (7) Memoize cell renderers, (8) Canvas rendering for extreme performance (CanvasTable). Accessibility: proper ARIA grid roles, keyboard navigation, screen reader announcements.",
    category: "Performance",
    difficulty: "HARD" as const,
    tags: ["data-grid", "virtualization", "performance"],
  },
  {
    questionText: "What are the challenges and solutions for managing CSS at scale in a large application?",
    idealAnswer: "Challenges: specificity conflicts, dead CSS, naming collisions, bundle size. Solutions: (1) CSS Modules — locally scoped class names, (2) Tailwind CSS — utility-first, purges unused styles, (3) CSS-in-JS with scoping (but runtime cost), (4) Design tokens for consistency, (5) Stylelint for linting, (6) Critical CSS extraction for above-fold rendering, (7) Layer cascade (@layer) for specificity management. Architecture: tokens → global styles → component styles → overrides.",
    category: "CSS",
    difficulty: "HARD" as const,
    tags: ["css", "architecture", "scalability"],
  },
  {
    questionText: "How do you implement advanced TypeScript patterns like branded types and template literal types?",
    idealAnswer: "Branded types add a phantom property to distinguish structurally identical types: `type UserId = string & { __brand: 'UserId' }` — prevents passing a random string as a user ID. Template literal types create string patterns: `type EventName = 'on${Capitalize<string>}'` matches 'onClick', 'onHover'. Other advanced patterns: conditional types (`T extends U ? X : Y`), mapped types with key remapping, and recursive types for deeply nested structures.",
    category: "TypeScript",
    difficulty: "HARD" as const,
    tags: ["typescript", "advanced-types", "branded-types"],
  },
];
