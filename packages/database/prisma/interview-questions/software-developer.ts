export const softwareDeveloperQuestions = [
  // EASY (30 questions)
  { questionText: "What is a variable in programming?", idealAnswer: "A variable is a named storage location in memory that holds a value which can be changed during program execution. Variables have a type, name, and value. They allow programs to store and manipulate data dynamically.", category: "Programming Fundamentals", difficulty: "EASY" as const, tags: ["fundamentals", "variables"] },
  { questionText: "What is the difference between == and === in JavaScript?", idealAnswer: "== performs type coercion before comparison, so '5' == 5 is true. === is strict equality that checks both value and type without coercion, so '5' === 5 is false. Always prefer === to avoid unexpected type conversion bugs.", category: "JavaScript", difficulty: "EASY" as const, tags: ["javascript", "operators", "comparison"] },
  { questionText: "What is an array and when would you use one?", idealAnswer: "An array is an ordered collection of elements accessed by index. Use arrays when you need to store multiple values of the same type, maintain order, or iterate over a collection. They provide O(1) access by index and are fundamental to most algorithms.", category: "Data Structures", difficulty: "EASY" as const, tags: ["data-structures", "arrays"] },
  { questionText: "Explain what Git is and why it's important.", idealAnswer: "Git is a distributed version control system that tracks changes in source code. It enables multiple developers to collaborate, maintains history of all changes, allows branching for parallel development, and provides mechanisms to merge work. It's essential for team collaboration and code backup.", category: "Git", difficulty: "EASY" as const, tags: ["git", "version-control"] },
  { questionText: "What is a function and why do we use them?", idealAnswer: "A function is a reusable block of code that performs a specific task. Functions promote code reuse, reduce duplication, improve readability, and make code easier to test and maintain. They accept parameters and can return values.", category: "Programming Fundamentals", difficulty: "EASY" as const, tags: ["fundamentals", "functions"] },
  { questionText: "What is the purpose of a SQL SELECT statement?", idealAnswer: "SELECT retrieves data from one or more database tables. It can filter rows with WHERE, sort with ORDER BY, limit results, and join multiple tables. It's the most fundamental SQL operation for reading data from relational databases.", category: "SQL", difficulty: "EASY" as const, tags: ["sql", "queries", "select"] },
  { questionText: "What is an API?", idealAnswer: "An API (Application Programming Interface) is a set of rules and protocols that allows different software applications to communicate. REST APIs use HTTP methods to perform CRUD operations. APIs enable integration between systems, microservices communication, and third-party service access.", category: "REST APIs", difficulty: "EASY" as const, tags: ["api", "rest", "web-development"] },
  { questionText: "What is the difference between let, const, and var in JavaScript?", idealAnswer: "var is function-scoped and hoisted, const and let are block-scoped. const cannot be reassigned after declaration (though objects/arrays can be mutated). let can be reassigned. Best practice is to use const by default, let when reassignment is needed, and avoid var.", category: "JavaScript", difficulty: "EASY" as const, tags: ["javascript", "variables", "scope"] },
  { questionText: "What is a primary key in a database?", idealAnswer: "A primary key is a column or combination of columns that uniquely identifies each row in a table. It must be unique and not null. Primary keys ensure data integrity and are used to establish relationships between tables through foreign keys.", category: "SQL", difficulty: "EASY" as const, tags: ["sql", "database", "primary-key"] },
  { questionText: "What is the purpose of a loop in programming?", idealAnswer: "A loop repeatedly executes a block of code until a condition is met. Common types include for loops (known iterations), while loops (condition-based), and for-each loops (iterating collections). Loops automate repetitive tasks and process collections of data.", category: "Programming Fundamentals", difficulty: "EASY" as const, tags: ["fundamentals", "loops", "control-flow"] },
  { questionText: "What is Python's list comprehension?", idealAnswer: "List comprehension is a concise way to create lists in Python using the syntax [expression for item in iterable if condition]. For example, [x*2 for x in range(10) if x > 3] creates a list of doubled values greater than 3. It's more readable and often faster than equivalent for loops.", category: "Python", difficulty: "EASY" as const, tags: ["python", "list-comprehension"] },
  { questionText: "What is a Git commit?", idealAnswer: "A commit is a snapshot of your project at a specific point in time. Each commit has a unique SHA hash, author info, timestamp, and message describing the changes. Commits form a history chain that allows you to track, review, and revert changes.", category: "Git", difficulty: "EASY" as const, tags: ["git", "commit", "version-control"] },
  { questionText: "What are HTTP methods GET and POST used for?", idealAnswer: "GET retrieves data from a server and should be idempotent with no side effects. POST sends data to create a new resource. GET parameters are in the URL (visible, limited size), while POST sends data in the request body (hidden, larger payloads). REST APIs use these along with PUT, PATCH, and DELETE.", category: "REST APIs", difficulty: "EASY" as const, tags: ["http", "rest", "get", "post"] },
  { questionText: "What is an object in JavaScript?", idealAnswer: "An object is a collection of key-value pairs where keys are strings and values can be any type including other objects and functions. Objects are used to group related data and behavior. They can be created with literals {}, constructors, or Object.create().", category: "JavaScript", difficulty: "EASY" as const, tags: ["javascript", "objects"] },
  { questionText: "What is a SQL JOIN and why is it used?", idealAnswer: "A JOIN combines rows from two or more tables based on a related column. INNER JOIN returns matching rows, LEFT JOIN returns all left table rows plus matches, RIGHT JOIN returns all right table rows plus matches. JOINs enable querying related data stored across normalized tables.", category: "SQL", difficulty: "EASY" as const, tags: ["sql", "joins", "database"] },
  { questionText: "What is a class in object-oriented programming?", idealAnswer: "A class is a blueprint for creating objects that defines properties (data) and methods (behavior). Classes support encapsulation, inheritance, and polymorphism. They enable code organization, reuse through inheritance, and abstraction of complex systems.", category: "Java", difficulty: "EASY" as const, tags: ["oop", "classes", "java"] },
  { questionText: "What is JSON and where is it used?", idealAnswer: "JSON (JavaScript Object Notation) is a lightweight data-interchange format that's easy for humans to read and machines to parse. It uses key-value pairs and arrays. JSON is the standard format for REST API communication, configuration files, and data storage.", category: "REST APIs", difficulty: "EASY" as const, tags: ["json", "api", "data-format"] },
  { questionText: "What is a Git branch?", idealAnswer: "A branch is an independent line of development that diverges from the main codebase. Branches allow parallel work on features, bug fixes, or experiments without affecting the main code. They can be merged back when work is complete, enabling team collaboration.", category: "Git", difficulty: "EASY" as const, tags: ["git", "branching"] },
  { questionText: "What is a dictionary in Python?", idealAnswer: "A dictionary is a mutable collection of key-value pairs with O(1) average lookup time using hash tables. Keys must be immutable (strings, numbers, tuples). Dictionaries are used for mappings, caching, counting occurrences, and any scenario requiring fast lookups by key.", category: "Python", difficulty: "EASY" as const, tags: ["python", "dictionaries", "data-structures"] },
  { questionText: "What is an exception and how do you handle it?", idealAnswer: "An exception is an error that occurs during program execution. Try-catch blocks handle exceptions gracefully: code that might fail goes in try, error handling in catch. This prevents crashes and allows meaningful error messages. Always catch specific exceptions rather than generic ones.", category: "Programming Fundamentals", difficulty: "EASY" as const, tags: ["error-handling", "exceptions", "try-catch"] },
  { questionText: "What is the difference between null and undefined in JavaScript?", idealAnswer: "undefined means a variable has been declared but not assigned a value — it's the default for uninitialized variables. null is an intentional assignment indicating 'no value'. typeof undefined is 'undefined' while typeof null is 'object' (a known JS quirk).", category: "JavaScript", difficulty: "EASY" as const, tags: ["javascript", "null", "undefined"] },
  { questionText: "What is a REST API endpoint?", idealAnswer: "An endpoint is a specific URL where an API receives requests, combining a base URL with a resource path like /api/users/123. Each endpoint corresponds to a specific resource and responds to HTTP methods. Well-designed endpoints use nouns for resources and HTTP verbs for actions.", category: "REST APIs", difficulty: "EASY" as const, tags: ["rest", "api", "endpoints"] },
  { questionText: "What is the WHERE clause in SQL?", idealAnswer: "WHERE filters rows in a query based on conditions. It supports comparison operators (=, <, >), logical operators (AND, OR, NOT), pattern matching (LIKE), range checking (BETWEEN), and set membership (IN). WHERE is essential for retrieving specific subsets of data from tables.", category: "SQL", difficulty: "EASY" as const, tags: ["sql", "where", "filtering"] },
  { questionText: "What is string interpolation?", idealAnswer: "String interpolation embeds expressions within string literals. In JavaScript, template literals use backticks and ${expression}. In Python, f-strings use f'text {expression}'. This is cleaner than string concatenation and makes dynamic string construction more readable.", category: "Programming Fundamentals", difficulty: "EASY" as const, tags: ["strings", "interpolation", "fundamentals"] },
  { questionText: "What is npm and what does it do?", idealAnswer: "npm (Node Package Manager) is the default package manager for Node.js. It manages project dependencies, allows installing third-party libraries, runs scripts defined in package.json, and provides a registry of open-source packages. npm install downloads dependencies, npm run executes scripts.", category: "Node.js", difficulty: "EASY" as const, tags: ["nodejs", "npm", "package-management"] },
  { questionText: "What is the purpose of .gitignore?", idealAnswer: ".gitignore specifies files and directories that Git should not track. Common entries include node_modules/, .env files, build outputs, and IDE settings. This keeps the repository clean, prevents sensitive data from being committed, and avoids unnecessary large files.", category: "Git", difficulty: "EASY" as const, tags: ["git", "gitignore"] },
  { questionText: "What is a boolean data type?", idealAnswer: "A boolean represents true or false values. Booleans are used in conditional statements, loops, and logical operations. In many languages, other types can be truthy or falsy — in JavaScript, 0, '', null, undefined, and NaN are falsy; everything else is truthy.", category: "Programming Fundamentals", difficulty: "EASY" as const, tags: ["fundamentals", "boolean", "data-types"] },
  { questionText: "What is inheritance in OOP?", idealAnswer: "Inheritance allows a class to inherit properties and methods from a parent class, enabling code reuse and hierarchical relationships. The child class can extend or override parent behavior. For example, Dog extends Animal inheriting common traits while adding dog-specific features.", category: "Java", difficulty: "EASY" as const, tags: ["oop", "inheritance", "java"] },
  { questionText: "What is a callback function?", idealAnswer: "A callback is a function passed as an argument to another function, to be executed later. Callbacks enable asynchronous programming — for example, handling API responses or event listeners. In modern JavaScript, Promises and async/await have largely replaced callbacks for cleaner code.", category: "JavaScript", difficulty: "EASY" as const, tags: ["javascript", "callbacks", "async"] },
  { questionText: "What does the GROUP BY clause do in SQL?", idealAnswer: "GROUP BY groups rows with the same values in specified columns, enabling aggregate functions like COUNT, SUM, AVG, MAX, and MIN per group. For example, SELECT department, COUNT(*) FROM employees GROUP BY department counts employees per department. HAVING filters groups after aggregation.", category: "SQL", difficulty: "EASY" as const, tags: ["sql", "group-by", "aggregation"] },
  // MEDIUM (40 questions)
  { questionText: "Explain closures in JavaScript with an example.", idealAnswer: "A closure is a function that retains access to its outer scope's variables even after the outer function has returned. This happens because functions in JavaScript form closures over their lexical environment. Common uses include data privacy, factory functions, and maintaining state in callbacks and event handlers.", category: "JavaScript", difficulty: "MEDIUM" as const, tags: ["javascript", "closures", "scope"] },
  { questionText: "What is the difference between SQL and NoSQL databases?", idealAnswer: "SQL databases are relational with fixed schemas, ACID compliance, and use structured query language (PostgreSQL, MySQL). NoSQL databases are non-relational with flexible schemas, eventual consistency, and various data models: document (MongoDB), key-value (Redis), column-family (Cassandra), graph (Neo4j). Choose based on data structure, scalability, and consistency needs.", category: "SQL", difficulty: "MEDIUM" as const, tags: ["sql", "nosql", "database"] },
  { questionText: "What are Promises in JavaScript and how do they work?", idealAnswer: "A Promise represents the eventual completion or failure of an asynchronous operation. It has three states: pending, fulfilled, or rejected. Promises chain with .then() for success and .catch() for errors. async/await provides syntactic sugar over Promises for more readable asynchronous code.", category: "JavaScript", difficulty: "MEDIUM" as const, tags: ["javascript", "promises", "async"] },
  { questionText: "Explain RESTful API design principles.", idealAnswer: "REST principles include: stateless communication (no server-side session), resource-based URLs using nouns (/users, not /getUsers), proper HTTP methods (GET, POST, PUT, DELETE), meaningful status codes (200, 201, 404, 500), consistent response format (JSON), pagination for large collections, and versioning (v1/v2).", category: "REST APIs", difficulty: "MEDIUM" as const, tags: ["rest", "api-design", "best-practices"] },
  { questionText: "What is the difference between an interface and an abstract class?", idealAnswer: "An interface defines a contract of methods without implementation (in Java/TypeScript). An abstract class can have both abstract and concrete methods plus state. A class can implement multiple interfaces but extend only one abstract class. Use interfaces for capabilities and abstract classes for shared base behavior.", category: "Java", difficulty: "MEDIUM" as const, tags: ["oop", "interface", "abstract-class", "java"] },
  { questionText: "Explain Git merge vs rebase.", idealAnswer: "Merge creates a new merge commit combining two branches, preserving full history but creating non-linear history. Rebase replays commits from one branch onto another, creating a linear history but rewriting commit hashes. Use merge for shared branches, rebase for local feature branches before merging to keep history clean.", category: "Git", difficulty: "MEDIUM" as const, tags: ["git", "merge", "rebase"] },
  { questionText: "What is middleware in Express.js?", idealAnswer: "Middleware functions execute during the request-response cycle, with access to req, res, and next(). They can modify requests/responses, execute code, end the cycle, or pass control to the next middleware. Common uses include authentication, logging, CORS, body parsing, and error handling.", category: "Node.js", difficulty: "MEDIUM" as const, tags: ["nodejs", "express", "middleware"] },
  { questionText: "Explain SQL indexing and when to use it.", idealAnswer: "An index is a data structure (usually B-tree) that speeds up data retrieval at the cost of slower writes and extra storage. Create indexes on columns frequently used in WHERE, JOIN, and ORDER BY clauses. Composite indexes cover multiple columns. Avoid over-indexing as each index slows INSERT/UPDATE operations.", category: "SQL", difficulty: "MEDIUM" as const, tags: ["sql", "indexing", "performance"] },
  { questionText: "What is TypeScript and why use it over JavaScript?", idealAnswer: "TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. It adds static type checking, interfaces, enums, and generics. Benefits include catching errors at compile time, better IDE support with autocompletion, improved refactoring safety, and self-documenting code through type annotations.", category: "TypeScript", difficulty: "MEDIUM" as const, tags: ["typescript", "javascript", "static-typing"] },
  { questionText: "Explain the concept of virtual DOM in React.", idealAnswer: "The Virtual DOM is a lightweight in-memory representation of the real DOM. When state changes, React creates a new virtual DOM tree, diffs it against the previous one (reconciliation), and batch-updates only the changed real DOM nodes. This minimizes expensive DOM operations and improves performance.", category: "React", difficulty: "MEDIUM" as const, tags: ["react", "virtual-dom", "performance"] },
  { questionText: "What are Python decorators?", idealAnswer: "Decorators are functions that modify the behavior of other functions using the @decorator syntax. They wrap a function, adding functionality before/after execution without modifying the original code. Common uses include logging, authentication, caching (@lru_cache), and timing. Decorators follow the open/closed principle.", category: "Python", difficulty: "MEDIUM" as const, tags: ["python", "decorators", "design-patterns"] },
  { questionText: "What is Docker and why is it useful?", idealAnswer: "Docker packages applications with their dependencies into containers — lightweight, portable, isolated environments. Containers ensure consistency across development, staging, and production. Docker uses images (blueprints) to create containers, Dockerfiles to define images, and docker-compose for multi-container apps.", category: "Docker", difficulty: "MEDIUM" as const, tags: ["docker", "containers", "devops"] },
  { questionText: "Explain the event loop in Node.js.", idealAnswer: "The event loop is Node.js's mechanism for handling asynchronous operations on a single thread. It processes callbacks from a queue: timers, I/O callbacks, idle/prepare, poll (I/O events), check (setImmediate), and close callbacks. This non-blocking model enables high concurrency without threads, making Node.js efficient for I/O-heavy applications.", category: "Node.js", difficulty: "MEDIUM" as const, tags: ["nodejs", "event-loop", "async"] },
  { questionText: "What is dependency injection and why is it useful?", idealAnswer: "Dependency injection passes dependencies to a class from the outside rather than creating them internally. This decouples components, improves testability (mock dependencies), and follows the Dependency Inversion Principle. DI containers automate this in frameworks like Spring (Java) or NestJS (TypeScript).", category: "Design Patterns", difficulty: "MEDIUM" as const, tags: ["design-patterns", "dependency-injection", "solid"] },
  { questionText: "Explain the difference between authentication and authorization.", idealAnswer: "Authentication verifies identity (who you are) — typically via username/password, tokens, or OAuth. Authorization determines permissions (what you can do) — checking roles, permissions, or policies after authentication. JWT tokens often carry both: identity claims for auth and role claims for authorization.", category: "Security", difficulty: "MEDIUM" as const, tags: ["security", "authentication", "authorization"] },
  { questionText: "What are Python generators and when would you use them?", idealAnswer: "Generators are functions that use yield to produce values lazily, one at a time, maintaining state between calls. They're memory-efficient for large datasets since they don't store all values in memory. Use generators for processing large files, infinite sequences, or any pipeline where you don't need all values simultaneously.", category: "Python", difficulty: "MEDIUM" as const, tags: ["python", "generators", "iterators"] },
  { questionText: "Explain CORS and how to handle it.", idealAnswer: "CORS (Cross-Origin Resource Sharing) is a browser security mechanism that restricts HTTP requests from one origin to another. Servers must include Access-Control-Allow-Origin headers to permit cross-origin requests. Preflight OPTIONS requests check allowed methods/headers. In Express, use the cors middleware to configure allowed origins.", category: "REST APIs", difficulty: "MEDIUM" as const, tags: ["cors", "security", "web-development"] },
  { questionText: "What is the difference between shallow copy and deep copy?", idealAnswer: "A shallow copy creates a new object but references the same nested objects — changes to nested objects affect both copies. A deep copy recursively copies all nested objects, creating completely independent copies. In JavaScript, use structuredClone() or JSON.parse(JSON.stringify()) for deep copy; spread operator for shallow.", category: "JavaScript", difficulty: "MEDIUM" as const, tags: ["javascript", "copying", "objects"] },
  { questionText: "Explain database normalization and its forms.", idealAnswer: "Normalization organizes data to reduce redundancy and improve integrity. 1NF: atomic values, no repeating groups. 2NF: 1NF plus no partial dependencies on composite keys. 3NF: 2NF plus no transitive dependencies. Over-normalization can hurt read performance; denormalization may be needed for query-heavy systems.", category: "SQL", difficulty: "MEDIUM" as const, tags: ["sql", "normalization", "database-design"] },
  { questionText: "What is the useState and useEffect hooks in React?", idealAnswer: "useState manages component state, returning [value, setter]. useEffect handles side effects (API calls, subscriptions, DOM manipulation) after render. useEffect's dependency array controls when it re-runs: empty array runs once, specific deps run on change, no array runs every render. Return a cleanup function for subscriptions.", category: "React", difficulty: "MEDIUM" as const, tags: ["react", "hooks", "state-management"] },
  { questionText: "What is a Dockerfile and what are its key instructions?", idealAnswer: "A Dockerfile defines how to build a Docker image. Key instructions: FROM (base image), WORKDIR (working directory), COPY/ADD (copy files), RUN (execute commands during build), ENV (environment variables), EXPOSE (document ports), CMD/ENTRYPOINT (runtime command). Multi-stage builds reduce image size by separating build and runtime stages.", category: "Docker", difficulty: "MEDIUM" as const, tags: ["docker", "dockerfile", "containers"] },
  { questionText: "Explain the SOLID principles.", idealAnswer: "S: Single Responsibility — each class has one reason to change. O: Open/Closed — open for extension, closed for modification. L: Liskov Substitution — subtypes must be substitutable for base types. I: Interface Segregation — prefer small specific interfaces. D: Dependency Inversion — depend on abstractions, not concretions.", category: "Design Patterns", difficulty: "MEDIUM" as const, tags: ["solid", "design-principles", "oop"] },
  { questionText: "What is the difference between PUT and PATCH?", idealAnswer: "PUT replaces an entire resource with the provided data — all fields must be included. PATCH partially updates a resource — only changed fields are sent. PUT is idempotent (same result on repeated calls). Use PUT for full replacements, PATCH for partial updates to minimize data transfer.", category: "REST APIs", difficulty: "MEDIUM" as const, tags: ["rest", "http-methods", "put", "patch"] },
  { questionText: "What are Java generics and why are they useful?", idealAnswer: "Generics allow classes, interfaces, and methods to operate on typed parameters (e.g., List<String>). They provide compile-time type safety, eliminate casting, and enable code reuse. Type erasure removes generic type info at runtime for backward compatibility. Bounded types (<T extends Number>) constrain type parameters.", category: "Java", difficulty: "MEDIUM" as const, tags: ["java", "generics", "type-safety"] },
  { questionText: "Explain how async/await works in JavaScript.", idealAnswer: "async functions return Promises implicitly. await pauses execution until a Promise resolves, making asynchronous code read like synchronous code. Error handling uses try/catch instead of .catch(). await can only be used inside async functions. Multiple independent awaits should use Promise.all() for parallel execution.", category: "JavaScript", difficulty: "MEDIUM" as const, tags: ["javascript", "async-await", "promises"] },
  { questionText: "What is the purpose of environment variables?", idealAnswer: "Environment variables store configuration outside code — database URLs, API keys, feature flags, and port numbers. They allow different configurations per environment (dev/staging/production) without code changes. Never commit secrets to Git. Use .env files locally with dotenv, and platform-specific config in production.", category: "Node.js", difficulty: "MEDIUM" as const, tags: ["environment-variables", "configuration", "security"] },
  { questionText: "What is SQL injection and how do you prevent it?", idealAnswer: "SQL injection is an attack where malicious SQL is inserted through user input to manipulate database queries. Prevent it by using parameterized queries/prepared statements (never string concatenation), ORM libraries (Prisma, Sequelize), input validation, least-privilege database accounts, and web application firewalls.", category: "Security", difficulty: "MEDIUM" as const, tags: ["security", "sql-injection", "database"] },
  { questionText: "Explain the concept of state management in React.", idealAnswer: "State management handles application data flow. Local state uses useState for component-specific data. Context API shares state across components without prop drilling. External libraries like Redux or Zustand manage complex global state with predictable patterns. Choose based on app complexity — start simple, add tools as needed.", category: "React", difficulty: "MEDIUM" as const, tags: ["react", "state-management", "redux"] },
  { questionText: "What is a Git pull request and why is it important?", idealAnswer: "A pull request is a proposal to merge changes from one branch into another, enabling code review before integration. PRs allow team members to review code, discuss changes, run CI checks, and catch bugs before merging. They serve as documentation of what changed and why, improving code quality.", category: "Git", difficulty: "MEDIUM" as const, tags: ["git", "pull-request", "code-review"] },
  { questionText: "What are AWS EC2 and S3?", idealAnswer: "EC2 (Elastic Compute Cloud) provides resizable virtual servers in the cloud for running applications. S3 (Simple Storage Service) is object storage for files, backups, and static assets with high durability. EC2 handles compute needs while S3 handles storage. Together they form the backbone of many cloud architectures.", category: "AWS", difficulty: "MEDIUM" as const, tags: ["aws", "ec2", "s3", "cloud"] },
  { questionText: "Explain the map, filter, and reduce array methods.", idealAnswer: "map transforms each element and returns a new array of same length. filter returns a new array with elements passing a test condition. reduce accumulates array elements into a single value using an accumulator. These functional methods avoid mutation, enable chaining, and are preferred over imperative loops for data transformations.", category: "JavaScript", difficulty: "MEDIUM" as const, tags: ["javascript", "array-methods", "functional"] },
  { questionText: "What is connection pooling in databases?", idealAnswer: "Connection pooling maintains a cache of reusable database connections instead of creating new ones for each request. This dramatically improves performance since establishing connections is expensive. Pools manage min/max connections, idle timeouts, and connection validation. Libraries like pg-pool or Prisma handle pooling automatically.", category: "SQL", difficulty: "MEDIUM" as const, tags: ["database", "connection-pooling", "performance"] },
  { questionText: "What is the difference between process and thread?", idealAnswer: "A process is an independent program execution with its own memory space. A thread is a lightweight unit of execution within a process sharing the same memory. Processes are isolated and communicate via IPC; threads share memory but need synchronization to avoid race conditions. Node.js uses a single thread with an event loop.", category: "Programming Fundamentals", difficulty: "MEDIUM" as const, tags: ["processes", "threads", "concurrency"] },
  { questionText: "Explain the Observer design pattern.", idealAnswer: "The Observer pattern defines a one-to-many dependency where a subject notifies all registered observers of state changes. This decouples the subject from observers — new observers can be added without modifying the subject. Examples include event listeners, pub/sub systems, and React's state update mechanism.", category: "Design Patterns", difficulty: "MEDIUM" as const, tags: ["design-patterns", "observer", "events"] },
  { questionText: "What is a lambda function in Python?", idealAnswer: "A lambda is an anonymous, single-expression function defined with the lambda keyword: lambda x: x*2. Lambdas are useful for short operations passed as arguments to higher-order functions like map(), filter(), sorted(). For complex logic, use regular named functions for readability.", category: "Python", difficulty: "MEDIUM" as const, tags: ["python", "lambda", "functional"] },
  { questionText: "Explain HTTP status codes and their categories.", idealAnswer: "1xx: Informational (100 Continue). 2xx: Success (200 OK, 201 Created, 204 No Content). 3xx: Redirection (301 Moved, 304 Not Modified). 4xx: Client errors (400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found). 5xx: Server errors (500 Internal, 502 Bad Gateway, 503 Service Unavailable).", category: "REST APIs", difficulty: "MEDIUM" as const, tags: ["http", "status-codes", "rest"] },
  { questionText: "What are React component lifecycle methods?", idealAnswer: "Class components have mounting (constructor, componentDidMount), updating (componentDidUpdate), and unmounting (componentWillUnmount) phases. In functional components, useEffect replaces all three: mount with empty deps, update with specific deps, and unmount via the cleanup return function. Modern React prefers hooks over lifecycle methods.", category: "React", difficulty: "MEDIUM" as const, tags: ["react", "lifecycle", "hooks"] },
  { questionText: "What is a transaction in databases?", idealAnswer: "A transaction groups multiple database operations into an atomic unit that either all succeed (commit) or all fail (rollback). ACID properties ensure Atomicity, Consistency, Isolation, and Durability. Transactions prevent partial updates that could leave data in an inconsistent state.", category: "SQL", difficulty: "MEDIUM" as const, tags: ["sql", "transactions", "acid"] },
  { questionText: "Explain the concept of immutability and its benefits.", idealAnswer: "Immutability means data cannot be changed after creation — instead, new copies are made with modifications. Benefits include predictable state, easier debugging, safe concurrency (no race conditions), efficient change detection (reference comparison), and better undo/redo support. React and Redux rely on immutability for performance optimizations.", category: "Programming Fundamentals", difficulty: "MEDIUM" as const, tags: ["immutability", "functional-programming", "state"] },
  { questionText: "What is the purpose of Docker Compose?", idealAnswer: "Docker Compose defines and runs multi-container applications using a YAML file. It specifies services, networks, volumes, and environment variables. docker-compose up starts all services with proper networking. It's essential for local development environments with multiple services like databases, caches, and application servers.", category: "Docker", difficulty: "MEDIUM" as const, tags: ["docker", "docker-compose", "devops"] },
  // HARD (30 questions)
  { questionText: "Explain how garbage collection works in Java vs JavaScript.", idealAnswer: "Java uses generational GC with young and old generations, primarily mark-and-sweep with compaction. JavaScript engines (V8) use generational GC with Scavenge for young generation and Mark-Compact for old generation. Both identify unreachable objects, but Java offers GC tuning options (G1, ZGC, Shenandoah) while V8 manages GC automatically with incremental/concurrent collection.", category: "Java", difficulty: "HARD" as const, tags: ["java", "javascript", "garbage-collection", "memory"] },
  { questionText: "Design a rate limiter for an API. What algorithms would you consider?", idealAnswer: "Common algorithms: Token Bucket (tokens refill at fixed rate, requests consume tokens), Sliding Window Log (track timestamps in sorted set), Sliding Window Counter (hybrid of fixed and sliding windows), Leaky Bucket (processes at constant rate). Consider distributed rate limiting with Redis. Implementation needs: key design (user/IP/endpoint), storage, atomic operations, and configurable limits.", category: "System Design", difficulty: "HARD" as const, tags: ["system-design", "rate-limiting", "algorithms"] },
  { questionText: "Explain the CAP theorem and its practical implications.", idealAnswer: "CAP theorem states distributed systems can guarantee at most two of three: Consistency (all nodes see same data), Availability (every request gets a response), Partition Tolerance (system works despite network partitions). Since partitions are inevitable, the real choice is CP (strong consistency, may reject requests) vs AP (always available, eventual consistency). Real systems make nuanced trade-offs per operation.", category: "System Design", difficulty: "HARD" as const, tags: ["distributed-systems", "cap-theorem", "system-design"] },
  { questionText: "How would you implement a caching strategy? Compare cache invalidation approaches.", idealAnswer: "Strategies: Cache-Aside (app manages cache reads/writes), Write-Through (write to cache and DB simultaneously), Write-Behind (write to cache, async DB write), Read-Through (cache loads on miss). Invalidation approaches: TTL-based expiration, event-driven invalidation, versioned keys. Challenges include cache stampede (use locking), stale data, and cold starts. Redis and Memcached are popular choices.", category: "System Design", difficulty: "HARD" as const, tags: ["caching", "system-design", "redis", "performance"] },
  { questionText: "Explain event-driven architecture and its trade-offs.", idealAnswer: "Event-driven architecture uses events to communicate between decoupled services via message brokers (Kafka, RabbitMQ). Producers publish events; consumers subscribe and react. Benefits: loose coupling, scalability, fault isolation. Trade-offs: eventual consistency, debugging complexity, event ordering challenges, and potential for event storms. Patterns include event sourcing and CQRS.", category: "Architecture", difficulty: "HARD" as const, tags: ["architecture", "event-driven", "microservices"] },
  { questionText: "How does the JavaScript prototype chain work?", idealAnswer: "Every JavaScript object has an internal [[Prototype]] link to another object. Property access traverses this chain until found or reaching null (Object.prototype's prototype). Constructor functions set __proto__ to the constructor's prototype property. ES6 classes are syntactic sugar over this mechanism. Understanding prototypes is key to inheritance, method delegation, and performance optimization.", category: "JavaScript", difficulty: "HARD" as const, tags: ["javascript", "prototypes", "inheritance"] },
  { questionText: "Explain database sharding strategies and trade-offs.", idealAnswer: "Sharding horizontally partitions data across multiple databases. Strategies: range-based (by date/ID range), hash-based (hash key to shard), directory-based (lookup table). Trade-offs include complex queries across shards, rebalancing difficulty, loss of transactions across shards, and increased operational complexity. Choose shard keys carefully to distribute load evenly and minimize cross-shard queries.", category: "Database", difficulty: "HARD" as const, tags: ["database", "sharding", "scalability"] },
  { questionText: "How would you design a microservices architecture for an e-commerce platform?", idealAnswer: "Services: User, Product Catalog, Order, Payment, Inventory, Notification, Search. Communication: synchronous REST/gRPC for queries, async events (Kafka) for state changes. Each service owns its database. API Gateway handles routing, auth, rate limiting. Patterns needed: saga for distributed transactions, circuit breaker for fault tolerance, service discovery, and centralized logging/tracing.", category: "Architecture", difficulty: "HARD" as const, tags: ["microservices", "system-design", "architecture"] },
  { questionText: "Explain TypeScript generics with advanced patterns.", idealAnswer: "Generics enable reusable typed code: function identity<T>(arg: T): T. Advanced patterns include constrained generics (T extends Interface), conditional types (T extends string ? A : B), mapped types (transforming object types), utility types (Partial<T>, Pick<T, K>, Record<K, V>), and template literal types. Generics ensure type safety while maintaining flexibility.", category: "TypeScript", difficulty: "HARD" as const, tags: ["typescript", "generics", "advanced-types"] },
  { questionText: "How does Node.js handle concurrent requests with a single thread?", idealAnswer: "Node.js uses libuv's event loop with non-blocking I/O. When async operations (file reads, network requests, DB queries) start, they're delegated to the OS or thread pool while the main thread continues. Completion callbacks are queued and processed in the event loop. CPU-intensive tasks block the loop — use worker_threads or child_process for those. This model handles thousands of concurrent connections efficiently.", category: "Node.js", difficulty: "HARD" as const, tags: ["nodejs", "concurrency", "event-loop"] },
  { questionText: "Explain OAuth 2.0 flow and its grant types.", idealAnswer: "OAuth 2.0 delegates authorization via access tokens. Authorization Code Grant: redirect to auth server, get code, exchange for tokens — most secure for web apps. PKCE variant for SPAs/mobile. Client Credentials: server-to-server without user. Refresh Token Grant: obtain new access tokens without re-auth. Implicit grant is deprecated. Tokens should be short-lived with refresh rotation.", category: "Security", difficulty: "HARD" as const, tags: ["oauth", "security", "authentication"] },
  { questionText: "Describe how you would implement a CI/CD pipeline.", idealAnswer: "Pipeline stages: 1) Source — trigger on Git push/PR. 2) Build — compile, install deps. 3) Test — unit, integration, e2e tests in parallel. 4) Static analysis — linting, security scanning, type checking. 5) Build artifacts — Docker images, tagged with commit SHA. 6) Deploy to staging — automated. 7) Deploy to production — manual approval or canary deployment. Use GitHub Actions, GitLab CI, or Jenkins. Include rollback mechanisms.", category: "DevOps", difficulty: "HARD" as const, tags: ["ci-cd", "devops", "automation"] },
  { questionText: "Explain React's reconciliation algorithm and fiber architecture.", idealAnswer: "React's reconciliation diffs virtual DOM trees to determine minimal DOM updates. Fiber is the reimplemented reconciliation engine that breaks rendering into chunks, enabling priority-based updates and concurrent rendering. Fiber nodes form a linked list tree, allowing React to pause/resume work. Key optimizations: same-type elements update in place, keys enable efficient list diffing, and different types trigger full remounts.", category: "React", difficulty: "HARD" as const, tags: ["react", "fiber", "reconciliation", "performance"] },
  { questionText: "How would you optimize a slow SQL query?", idealAnswer: "Steps: 1) Use EXPLAIN ANALYZE to understand the execution plan. 2) Add indexes on WHERE, JOIN, ORDER BY columns. 3) Avoid SELECT * — only fetch needed columns. 4) Optimize JOINs — ensure join columns are indexed. 5) Use query rewriting — subqueries to JOINs, LIMIT early. 6) Consider partitioning for large tables. 7) Denormalize if needed for read-heavy workloads. 8) Check for N+1 query problems.", category: "SQL", difficulty: "HARD" as const, tags: ["sql", "performance", "query-optimization"] },
  { questionText: "Explain Python's GIL and its implications for multithreading.", idealAnswer: "The Global Interpreter Lock (GIL) in CPython allows only one thread to execute Python bytecode at a time. This means CPU-bound multi-threaded code won't achieve true parallelism. I/O-bound tasks still benefit from threading since the GIL is released during I/O waits. For CPU-bound parallelism, use multiprocessing, concurrent.futures, or C extensions that release the GIL.", category: "Python", difficulty: "HARD" as const, tags: ["python", "gil", "concurrency", "multithreading"] },
  { questionText: "What is the difference between horizontal and vertical scaling?", idealAnswer: "Vertical scaling adds more resources (CPU, RAM) to a single machine — simpler but has hardware limits and single point of failure. Horizontal scaling adds more machines — enables near-infinite scaling, fault tolerance, but requires load balancing, distributed state management, and handling data consistency. Modern architectures prefer horizontal scaling with stateless services.", category: "System Design", difficulty: "HARD" as const, tags: ["scaling", "system-design", "architecture"] },
  { questionText: "Explain how JWT tokens work and their security considerations.", idealAnswer: "JWT contains header (algorithm, type), payload (claims like userId, expiry), and signature (HMAC or RSA). The server validates the signature without database lookup. Security considerations: use short expiration times, implement refresh token rotation, store in httpOnly cookies (not localStorage), validate all claims, use strong signing keys, and implement token blacklisting for logout.", category: "Security", difficulty: "HARD" as const, tags: ["jwt", "security", "authentication", "tokens"] },
  { questionText: "How would you handle database migrations in production?", idealAnswer: "Use migration tools (Prisma Migrate, Flyway, Alembic) for versioned, repeatable schema changes. Steps: write migration in dev, test in staging, deploy to production. Always make migrations backward-compatible — add columns before removing old ones. Use multi-step deployments for breaking changes. Avoid locking tables with large migrations; use online schema change tools (pt-osc, gh-ost).", category: "Database", difficulty: "HARD" as const, tags: ["database", "migrations", "devops", "production"] },
  { questionText: "Explain the Strategy design pattern with a practical example.", idealAnswer: "Strategy defines a family of interchangeable algorithms encapsulated in separate classes, selected at runtime. Example: a payment system with CreditCardStrategy, PayPalStrategy, CryptoStrategy — each implementing a pay() method. The context class delegates to the current strategy without knowing implementation details. This follows open/closed principle and eliminates large conditional blocks.", category: "Design Patterns", difficulty: "HARD" as const, tags: ["design-patterns", "strategy", "oop"] },
  { questionText: "What is eventual consistency and when is it acceptable?", idealAnswer: "Eventual consistency means all replicas will converge to the same state given enough time, without guaranteeing immediate consistency after writes. It's acceptable for social media feeds, analytics, search indexes, and shopping carts where slight delays are tolerable. Not suitable for financial transactions, inventory counts, or anything requiring strong consistency.", category: "Distributed Systems", difficulty: "HARD" as const, tags: ["distributed-systems", "consistency", "databases"] },
  { questionText: "How do you prevent and detect memory leaks in Node.js?", idealAnswer: "Common causes: unclosed listeners, global variable accumulation, closures retaining references, uncleared timers/intervals, and circular references. Detection: monitor heap usage with process.memoryUsage(), use --inspect with Chrome DevTools heap snapshots, or clinic.js. Prevention: remove event listeners, use WeakMap/WeakSet for caches, implement proper cleanup, and profile regularly.", category: "Node.js", difficulty: "HARD" as const, tags: ["nodejs", "memory-leaks", "debugging", "performance"] },
  { questionText: "Explain WebSocket protocol and when to use it over HTTP.", idealAnswer: "WebSockets provide full-duplex, persistent connections between client and server over a single TCP connection, initiated via HTTP upgrade. Use for real-time features: chat, live notifications, collaborative editing, gaming, and live dashboards. HTTP is better for request-response patterns, cacheable resources, and stateless operations. Consider SSE for server-to-client-only streaming.", category: "Web Development", difficulty: "HARD" as const, tags: ["websockets", "real-time", "http", "protocols"] },
  { questionText: "How would you implement a search feature with autocomplete?", idealAnswer: "Backend: use Elasticsearch or PostgreSQL full-text search with trigram indexes. Implement prefix matching, fuzzy search, and relevance scoring. Frontend: debounce input (300ms), cancel pending requests, cache results, show dropdown with highlighting. Optimize with trie data structures for prefix suggestions. Consider personalization based on user history and popularity-weighted results.", category: "System Design", difficulty: "HARD" as const, tags: ["search", "autocomplete", "system-design", "elasticsearch"] },
  { questionText: "Explain the differences between serverless and container-based architectures.", idealAnswer: "Serverless (Lambda, Cloud Functions): auto-scales to zero, pay per invocation, no server management, cold starts, 15-min execution limits. Containers (ECS, Kubernetes): more control, consistent performance, long-running processes, but require capacity planning and orchestration. Serverless suits event-driven, sporadic workloads; containers suit consistent, long-running services needing full control.", category: "AWS", difficulty: "HARD" as const, tags: ["serverless", "containers", "aws", "architecture"] },
  { questionText: "What is the N+1 query problem and how do you solve it?", idealAnswer: "N+1 occurs when fetching a list of N items, then making N additional queries for related data (e.g., fetching 100 posts then 100 separate author queries). Solutions: eager loading (JOIN or include in ORMs), batch loading (DataLoader pattern), database views, or GraphQL's DataLoader. In Prisma, use include/select. Always check query logs during development.", category: "Database", difficulty: "HARD" as const, tags: ["database", "n-plus-one", "performance", "orm"] },
  { questionText: "How would you implement end-to-end encryption in a messaging app?", idealAnswer: "Use Signal Protocol or similar: each user generates public/private key pairs. Messages encrypted with recipient's public key, decrypted with their private key. Implement key exchange (X3DH), double ratchet for forward secrecy, and pre-key bundles for offline messaging. Store encrypted messages server-side. Keys never leave the device. Challenge: key management, multi-device sync, and group messaging.", category: "Security", difficulty: "HARD" as const, tags: ["encryption", "security", "cryptography"] },
  { questionText: "Explain how React Server Components work and their benefits.", idealAnswer: "Server Components render on the server, sending serialized UI (not HTML) to the client. They can directly access databases, file systems, and internal APIs without API endpoints. Benefits: zero client-side JavaScript for server components, reduced bundle size, streaming rendering, and automatic code splitting. Client Components handle interactivity. This hybrid model optimizes for both performance and user experience.", category: "React", difficulty: "HARD" as const, tags: ["react", "server-components", "nextjs", "performance"] },
  { questionText: "How do you handle distributed transactions across microservices?", idealAnswer: "Saga pattern orchestrates a sequence of local transactions with compensating actions for rollback. Two types: choreography (event-driven, each service listens and acts) and orchestration (central coordinator manages steps). Two-phase commit (2PC) ensures strong consistency but is slow and blocks resources. Prefer sagas with eventual consistency for most microservice scenarios. Implement idempotency keys to handle retries.", category: "Architecture", difficulty: "HARD" as const, tags: ["microservices", "distributed-transactions", "saga", "architecture"] },
  { questionText: "What is the difference between concurrency and parallelism?", idealAnswer: "Concurrency is dealing with multiple tasks at once (structure) — tasks make progress through interleaving on one or more cores. Parallelism is doing multiple tasks simultaneously (execution) — requires multiple cores/processors. Node.js is concurrent but single-threaded. Go achieves both via goroutines. Concurrency is about design; parallelism is about execution. Both are needed for high-performance systems.", category: "Programming Fundamentals", difficulty: "HARD" as const, tags: ["concurrency", "parallelism", "multithreading"] },
  { questionText: "Explain container orchestration with Kubernetes concepts.", idealAnswer: "Kubernetes manages containerized apps across clusters. Pods are the smallest unit (one or more containers). Deployments manage replica sets with rolling updates. Services provide stable networking with load balancing. ConfigMaps/Secrets manage configuration. Ingress handles external traffic routing. Horizontal Pod Autoscaler scales based on metrics. Namespaces provide isolation. Helm charts package K8s manifests.", category: "Docker", difficulty: "HARD" as const, tags: ["kubernetes", "docker", "orchestration", "devops"] },
];
