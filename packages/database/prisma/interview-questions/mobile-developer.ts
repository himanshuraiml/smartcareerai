export const mobileDeveloperQuestions = [
  // ==================== React Native (10 questions) ====================
  {
    questionText: "What is React Native and how does it differ from traditional native mobile development?",
    idealAnswer: "React Native is a JavaScript framework created by Meta that allows developers to build mobile applications using React and JavaScript that render as true native components. Unlike traditional native development where you write separate codebases in Swift/Objective-C for iOS and Kotlin/Java for Android, React Native uses a single JavaScript codebase that communicates with native modules through a bridge architecture. The framework translates React components into native platform-specific widgets, so a <View> becomes a UIView on iOS and an android.view on Android. While it offers significant code sharing and faster development cycles, performance-critical features may still require writing native modules directly.",
    category: "React Native",
    difficulty: "EASY" as const,
    tags: ["react-native", "cross-platform", "javascript", "mobile-fundamentals"],
  },
  {
    questionText: "Explain the React Native bridge and how it facilitates communication between JavaScript and native code.",
    idealAnswer: "The React Native bridge is an asynchronous messaging layer that serializes data between the JavaScript thread and the native thread using JSON. When a React component needs to interact with native APIs, the bridge queues messages, batches them for efficiency, and sends them across the boundary. This architecture means JavaScript never directly calls native methods; instead, it sends serialized commands that native modules interpret and execute. In the new architecture (Fabric and TurboModules), the bridge is being replaced by the JavaScript Interface (JSI), which allows JavaScript to hold direct references to C++ host objects, enabling synchronous calls and significantly reducing serialization overhead.",
    category: "React Native",
    difficulty: "MEDIUM" as const,
    tags: ["react-native", "bridge", "architecture", "jsi"],
  },
  {
    questionText: "How do you handle navigation in a React Native application?",
    idealAnswer: "The most widely used navigation solution in React Native is React Navigation, which provides stack, tab, and drawer navigators out of the box. React Navigation uses a JavaScript-based approach where screen transitions are managed through a navigation state tree, and it supports deep linking, screen params, and nested navigators. An alternative is React Native Navigation by Wix, which uses fully native navigation controllers for each screen, offering better performance for complex navigation hierarchies. When setting up navigation, you define a NavigationContainer at the root, configure your navigator stacks, and use hooks like useNavigation and useRoute to programmatically navigate and access route parameters within components.",
    category: "React Native",
    difficulty: "EASY" as const,
    tags: ["react-native", "navigation", "react-navigation", "routing"],
  },
  {
    questionText: "What are TurboModules in React Native's new architecture, and what problems do they solve?",
    idealAnswer: "TurboModules are a re-engineered native module system in React Native's new architecture that replaces the traditional bridge-based native modules with a more performant approach using the JavaScript Interface (JSI). They solve several problems: native modules are now lazily loaded instead of being initialized at startup, which significantly improves app launch time. TurboModules use C++ to create direct bindings between JavaScript and native code, eliminating the need for JSON serialization and enabling synchronous method calls when needed. They also provide type-safe interfaces through code generation from JavaScript specs, reducing runtime errors and improving developer experience. This architecture allows for more efficient memory usage since modules are only instantiated when first accessed.",
    category: "React Native",
    difficulty: "HARD" as const,
    tags: ["react-native", "turbomodules", "new-architecture", "jsi", "performance"],
  },
  {
    questionText: "How do you optimize FlatList performance in React Native for large datasets?",
    idealAnswer: "Optimizing FlatList involves several key strategies to minimize re-renders and memory usage. First, use the getItemLayout prop to skip dynamic measurement when items have fixed heights, and always provide a stable keyExtractor to help React track item identity efficiently. Implement React.memo or PureComponent for list item components to prevent unnecessary re-renders, and use the windowSize prop to control how many off-screen items are rendered in memory. Setting removeClippedSubviews to true on Android recycles off-screen views, and adjusting maxToRenderPerBatch and updateCellsBatchingPeriod helps balance rendering speed with responsiveness. For extremely large datasets, consider using FlashList from Shopify, which provides significantly better performance through cell recycling similar to native RecyclerView and UICollectionView.",
    category: "React Native",
    difficulty: "MEDIUM" as const,
    tags: ["react-native", "flatlist", "performance", "optimization", "lists"],
  },
  {
    questionText: "Explain how to create and use a native module in React Native to expose platform-specific functionality.",
    idealAnswer: "Creating a native module involves writing platform-specific code in Java/Kotlin for Android or Objective-C/Swift for iOS and registering it so React Native can invoke it from JavaScript. On Android, you create a class extending ReactContextBaseJavaModule, annotate methods with @ReactMethod, and register the module through a ReactPackage. On iOS, you create a class conforming to RCTBridgeModule, use RCT_EXPORT_METHOD macros, and include it in the project. The native module can return data via promises or callbacks, and emit events to JavaScript using RCTDeviceEventEmitter on Android or RCTEventEmitter on iOS. With the new architecture, you define a TurboModule spec in JavaScript using codegen, which generates type-safe C++ bindings and scaffold code for both platforms automatically.",
    category: "React Native",
    difficulty: "HARD" as const,
    tags: ["react-native", "native-modules", "platform-specific", "bridge", "ios", "android"],
  },
  {
    questionText: "What is the purpose of the useEffect hook in React Native, and how does it relate to component lifecycle?",
    idealAnswer: "The useEffect hook in React Native serves the same purpose as in React: it lets you perform side effects in functional components, replacing the componentDidMount, componentDidUpdate, and componentWillUnmount lifecycle methods. When called with an empty dependency array, it runs once after the initial render (like componentDidMount); with dependencies, it re-runs whenever those values change (like componentDidUpdate with conditions). The cleanup function returned from useEffect runs before the effect re-executes and when the component unmounts, making it ideal for cleaning up subscriptions, timers, or event listeners. In React Native specifically, useEffect is commonly used for fetching data on screen focus, setting up native event listeners, and managing AppState changes between foreground and background.",
    category: "React Native",
    difficulty: "EASY" as const,
    tags: ["react-native", "hooks", "useEffect", "lifecycle", "react"],
  },
  {
    questionText: "How does Hermes improve React Native app performance, and what are its key features?",
    idealAnswer: "Hermes is a lightweight JavaScript engine developed by Meta specifically optimized for running React Native applications on mobile devices. It improves performance primarily through ahead-of-time (AOT) compilation, converting JavaScript source code into optimized bytecode during the build process rather than at runtime, which dramatically reduces app startup time (often by 50% or more). Hermes uses a smaller memory footprint compared to JavaScriptCore by employing techniques like lazy compilation and on-demand parsing, which is particularly beneficial on memory-constrained devices. It also features a garbage collector optimized for mobile with generational collection and on-demand allocation, reducing jank caused by GC pauses. Starting with React Native 0.70, Hermes is the default engine for both iOS and Android, and it includes built-in support for modern JavaScript features like Proxy objects and Intl APIs.",
    category: "React Native",
    difficulty: "MEDIUM" as const,
    tags: ["react-native", "hermes", "javascript-engine", "performance", "optimization"],
  },
  {
    questionText: "Describe the Fabric rendering system in React Native's new architecture.",
    idealAnswer: "Fabric is the new rendering system in React Native's new architecture that replaces the legacy renderer by moving UI operations to C++ and enabling synchronous access between JavaScript and the native UI thread. It uses a shadow tree written in C++ that can be shared across platforms, allowing layout calculations (using Yoga) to happen on any thread without the serialization overhead of the old bridge. Fabric supports concurrent rendering features from React 18, enabling priorities for UI updates, interruptible rendering, and Suspense integration. One of its key improvements is that it can create and update native views synchronously when needed, which eliminates visual flickering during complex UI transitions that was common with the asynchronous bridge. Fabric also simplifies the rendering pipeline by reducing the number of thread hops required to display a frame, resulting in smoother animations and faster initial renders.",
    category: "React Native",
    difficulty: "HARD" as const,
    tags: ["react-native", "fabric", "new-architecture", "rendering", "c++"],
  },
  {
    questionText: "How do you handle platform-specific code in React Native?",
    idealAnswer: "React Native provides several approaches for writing platform-specific code depending on the granularity needed. The Platform module offers Platform.OS to conditionally execute code based on the platform, and Platform.select to return platform-specific values inline within a component. For larger divergences, you can use platform-specific file extensions like Component.ios.tsx and Component.android.tsx, and the bundler will automatically resolve the correct file for each platform. The Platform.Version property lets you check the OS version for API-level-specific behavior, which is particularly useful for Android API levels. When the differences are substantial enough to warrant entirely separate implementations, you can use native modules or platform-specific folders within your project structure to keep the codebases cleanly separated.",
    category: "React Native",
    difficulty: "MEDIUM" as const,
    tags: ["react-native", "platform-specific", "ios", "android", "cross-platform"],
  },

  // ==================== Swift/iOS (10 questions) ====================
  {
    questionText: "What are optionals in Swift, and why are they important for iOS development?",
    idealAnswer: "Optionals in Swift represent a variable that can hold either a value or nil (the absence of a value), declared using a question mark after the type like String?. They are fundamental to Swift's type safety because they force developers to explicitly handle the possibility of missing values, preventing null pointer exceptions that are common in other languages. You can safely unwrap optionals using if let or guard let for optional binding, use the nil coalescing operator (??) to provide default values, or use optional chaining (?.) to access properties on potentially nil objects. Force unwrapping with the exclamation mark (!) should be used sparingly as it will crash the app if the value is nil. Optionals are especially important in iOS development because many UIKit and framework APIs return optional values, such as dictionary lookups, type casting, and storyboard outlet connections.",
    category: "iOS Development",
    difficulty: "EASY" as const,
    tags: ["swift", "ios", "optionals", "type-safety", "fundamentals"],
  },
  {
    questionText: "Explain the difference between structs and classes in Swift and when you would use each.",
    idealAnswer: "Structs in Swift are value types that are copied when assigned or passed to functions, while classes are reference types where variables hold a reference to the same instance in memory. Structs are preferred for modeling simple data with no need for inheritance, as they are allocated on the stack (when possible), are thread-safe by default due to their copy semantics, and benefit from compiler optimizations like copy-on-write for standard library types. Classes should be used when you need inheritance, reference semantics (multiple variables pointing to the same instance), or deinitializers for cleanup. In practice, Apple recommends defaulting to structs and only using classes when you specifically need reference behavior; SwiftUI views are all structs, while UIKit view controllers are classes. Classes also support identity comparison using the === operator, which checks whether two variables point to the same instance.",
    category: "iOS Development",
    difficulty: "MEDIUM" as const,
    tags: ["swift", "ios", "structs", "classes", "value-types", "reference-types"],
  },
  {
    questionText: "What is SwiftUI and how does it differ from UIKit?",
    idealAnswer: "SwiftUI is Apple's declarative UI framework introduced in 2019 that lets you describe your interface as a function of state using Swift code, whereas UIKit is the imperative framework where you manually create, configure, and update UI elements. In SwiftUI, you declare views as structs conforming to the View protocol, and the framework automatically updates the UI when the underlying state changes through property wrappers like @State, @Binding, and @ObservedObject. UIKit uses a delegate and target-action pattern with view controllers managing view hierarchies, requires manual layout through Auto Layout constraints or frame calculations, and uses a more traditional object-oriented MVC approach. SwiftUI offers live previews in Xcode, works across all Apple platforms with a single API, and requires significantly less boilerplate code, but UIKit remains more mature with broader API coverage and is still necessary for certain advanced customizations.",
    category: "iOS Development",
    difficulty: "EASY" as const,
    tags: ["swift", "ios", "swiftui", "uikit", "declarative-ui"],
  },
  {
    questionText: "Describe how Automatic Reference Counting (ARC) works in Swift, and how you prevent retain cycles.",
    idealAnswer: "ARC automatically manages memory in Swift by tracking the number of strong references to each class instance and deallocating the instance when the count reaches zero. Each time you assign a class instance to a variable, property, or constant, a strong reference is created that increments the count, and when the reference goes out of scope or is set to nil, the count decrements. Retain cycles occur when two objects hold strong references to each other, preventing either from being deallocated; this is resolved using weak references (which become nil when the referenced object is deallocated) or unowned references (which assume the object will always exist and crash if accessed after deallocation). In closures, retain cycles commonly occur when a closure captures self strongly; this is addressed by using capture lists like [weak self] or [unowned self] at the beginning of the closure. Memory leaks from retain cycles can be detected using Xcode's Memory Graph Debugger or Instruments' Leaks tool.",
    category: "iOS Development",
    difficulty: "MEDIUM" as const,
    tags: ["swift", "ios", "arc", "memory-management", "retain-cycles"],
  },
  {
    questionText: "What are Swift protocols, and how do protocol-oriented programming patterns benefit iOS development?",
    idealAnswer: "Swift protocols define a blueprint of methods, properties, and requirements that conforming types must implement, similar to interfaces in other languages but with additional capabilities like protocol extensions, associated types, and conditional conformance. Protocol-oriented programming (POP) is a paradigm emphasized in Swift where you compose behavior through protocol conformance and default implementations rather than class inheritance, enabling value types like structs and enums to share behavior. Protocol extensions allow you to provide default method implementations, so conforming types get functionality for free while retaining the ability to override; this is how Swift's standard library achieves features like map and filter on any Sequence. POP promotes composition over inheritance, leading to more flexible, testable code since you can easily create mock implementations for testing and combine multiple protocols without the diamond inheritance problem. Real-world examples include the Codable protocol for JSON serialization, Equatable for value comparison, and custom protocols for dependency injection in MVVM architectures.",
    category: "iOS Development",
    difficulty: "HARD" as const,
    tags: ["swift", "ios", "protocols", "pop", "design-patterns"],
  },
  {
    questionText: "Explain the iOS app lifecycle and the key states an app transitions through.",
    idealAnswer: "An iOS app transitions through five primary states: Not Running (the app hasn't been launched or was terminated), Inactive (the app is in the foreground but not receiving events, such as during a phone call overlay), Active (the app is in the foreground and receiving events normally), Background (the app is executing code but not visible, given limited execution time), and Suspended (the app is in memory but not executing code). These transitions are managed through the UIApplicationDelegate methods or the SceneDelegate in modern multi-window apps, with key callbacks including applicationDidBecomeActive, applicationWillResignActive, applicationDidEnterBackground, and applicationWillTerminate. In SwiftUI, you can observe scene phases using the @Environment(\\.scenePhase) property wrapper, which provides .active, .inactive, and .background states. Understanding the lifecycle is critical for saving user data when entering the background, pausing timers and animations when becoming inactive, and properly restoring state when returning to the foreground.",
    category: "iOS Development",
    difficulty: "MEDIUM" as const,
    tags: ["swift", "ios", "app-lifecycle", "uiapplication", "scene-delegate"],
  },
  {
    questionText: "What are Swift concurrency features like async/await and actors, and how do they improve iOS development?",
    idealAnswer: "Swift's structured concurrency, introduced in Swift 5.5, provides async/await syntax for writing asynchronous code that reads like synchronous code, eliminating deeply nested completion handler callbacks (callback hell). Async functions are marked with the async keyword and can suspend execution at await points, allowing the system to use the thread for other work while waiting for results, and they propagate errors naturally with try/catch. Actors are reference types that protect their mutable state by ensuring only one task accesses their properties at a time, using a serialized execution context similar to a serial dispatch queue but enforced at compile time. Task groups and TaskGroup allow structured parallel execution of multiple async operations with automatic cancellation propagation, while @MainActor ensures UI updates happen on the main thread. These features replace many common patterns involving DispatchQueue, OperationQueue, and completion handlers, making concurrent code safer, more readable, and less prone to data races.",
    category: "iOS Development",
    difficulty: "HARD" as const,
    tags: ["swift", "ios", "concurrency", "async-await", "actors", "structured-concurrency"],
  },
  {
    questionText: "How does Core Data work in iOS, and what are its main components?",
    idealAnswer: "Core Data is Apple's object graph and persistence framework that manages the model layer of an application, storing structured data locally on the device. Its main components are the NSManagedObjectModel (defines entities, attributes, and relationships in an .xcdatamodeld file), NSPersistentStoreCoordinator (mediates between the object model and the actual storage), NSManagedObjectContext (the in-memory scratchpad for creating, reading, updating, and deleting managed objects), and NSPersistentContainer (a convenience wrapper that sets up the entire Core Data stack). Data is fetched using NSFetchRequest with support for predicates, sort descriptors, batch sizes, and faulting (lazy loading of relationships). Core Data supports features like undo/redo management, data validation, automatic iCloud syncing via NSPersistentCloudKitContainer, and lightweight migrations for schema changes. While powerful, many modern iOS apps now prefer SwiftData (introduced in iOS 17) which provides a more Swift-native API with macro-based model definitions.",
    category: "iOS Development",
    difficulty: "HARD" as const,
    tags: ["swift", "ios", "core-data", "persistence", "database"],
  },
  {
    questionText: "What is the delegation pattern in iOS, and can you give a common example?",
    idealAnswer: "The delegation pattern is a design pattern in iOS where one object delegates responsibility for certain behaviors to another object that conforms to a specific protocol, promoting loose coupling between components. The delegating object holds a weak reference to its delegate (to avoid retain cycles) and calls protocol methods on the delegate when specific events occur. A classic example is UITableView, which uses UITableViewDataSource to ask its delegate for data (number of sections, cells for each row) and UITableViewDelegate to notify about user interactions (row selection, scrolling). To implement delegation, you define a protocol with required and optional methods, add a weak delegate property to the delegating class, and have the receiving class conform to the protocol and set itself as the delegate. This pattern is foundational in UIKit and is used extensively in text fields, collection views, scroll views, and many other framework components.",
    category: "iOS Development",
    difficulty: "EASY" as const,
    tags: ["swift", "ios", "delegation", "design-patterns", "uikit"],
  },
  {
    questionText: "Explain how Auto Layout works in iOS and describe its constraint-based system.",
    idealAnswer: "Auto Layout is iOS's constraint-based layout system that calculates the position and size of views dynamically based on a set of linear equations describing spatial relationships between views. Constraints define rules like 'this button's leading edge should be 16 points from the safe area' or 'these two views should have equal widths,' and the layout engine solves these equations to produce a final frame for each view. Each view needs enough constraints to determine its x position, y position, width, and height, though intrinsic content size (like text in a label) can satisfy width and height requirements. Constraints have priorities from 1 to 1000, with required (1000) constraints that must be satisfied and optional constraints that the system tries to satisfy as closely as possible. You can create constraints programmatically using NSLayoutConstraint, the visual format language, or layout anchors (the preferred modern approach), and debugging layout issues is aided by Xcode's view debugger and console warnings about ambiguous or conflicting constraints.",
    category: "iOS Development",
    difficulty: "MEDIUM" as const,
    tags: ["swift", "ios", "auto-layout", "constraints", "ui-layout"],
  },

  // ==================== Kotlin/Android (10 questions) ====================
  {
    questionText: "What is Kotlin, and what advantages does it offer over Java for Android development?",
    idealAnswer: "Kotlin is a statically-typed programming language developed by JetBrains that has been Google's preferred language for Android development since 2019, running on the JVM and fully interoperable with Java. It offers null safety built into the type system where variables are non-nullable by default and nullable types must be explicitly declared with a question mark, drastically reducing NullPointerException crashes. Kotlin provides concise syntax features including data classes (auto-generating equals, hashCode, toString), extension functions, scope functions (let, apply, also, run, with), and smart casts that reduce boilerplate code by approximately 40% compared to Java. It supports modern language features like coroutines for asynchronous programming, sealed classes for representing restricted hierarchies, and destructuring declarations. Kotlin is fully interoperable with existing Java code, meaning you can gradually migrate an Android project and use Java libraries seamlessly.",
    category: "Android Development",
    difficulty: "EASY" as const,
    tags: ["kotlin", "android", "java", "mobile-fundamentals"],
  },
  {
    questionText: "Explain the Android Activity lifecycle and its key callback methods.",
    idealAnswer: "The Android Activity lifecycle defines the series of states an Activity goes through from creation to destruction, managed by the system through callback methods. The key callbacks in order are: onCreate (initialize the activity, inflate layout, bind data), onStart (activity becomes visible), onResume (activity comes to foreground and is interactive), onPause (another activity is coming to foreground; save transient state), onStop (activity is no longer visible), and onDestroy (activity is finishing or being destroyed by the system). Configuration changes like screen rotation cause the activity to be destroyed and recreated (onDestroy then onCreate), which is why persisting state through onSaveInstanceState or using ViewModel is critical. The onRestart callback occurs between onStop and onStart when the user navigates back to the activity. Understanding this lifecycle is essential for managing resources properly, such as registering/unregistering listeners in onResume/onPause and releasing heavy resources in onStop.",
    category: "Android Development",
    difficulty: "EASY" as const,
    tags: ["kotlin", "android", "activity-lifecycle", "callbacks"],
  },
  {
    questionText: "What is Jetpack Compose, and how does it change Android UI development?",
    idealAnswer: "Jetpack Compose is Android's modern declarative UI toolkit that replaces the traditional XML-based layout system with composable functions written entirely in Kotlin. Instead of defining layouts in XML and manipulating views imperatively, you write @Composable functions that describe your UI as a function of state, and Compose automatically recomposes (re-renders) only the parts of the UI that changed when state updates. Compose uses a Kotlin compiler plugin to transform composable functions into an efficient UI tree, with intelligent recomposition that skips unchanged composables and a slot table for storing state. It integrates deeply with other Jetpack libraries like ViewModel, Navigation, and Hilt for dependency injection, and provides built-in support for Material Design 3, animations, theming, and accessibility. Compose can interop with existing View-based code through ComposeView (embedding Compose in XML) and AndroidView (embedding Views in Compose), enabling gradual migration of existing apps.",
    category: "Android Development",
    difficulty: "MEDIUM" as const,
    tags: ["kotlin", "android", "jetpack-compose", "declarative-ui", "modern-android"],
  },
  {
    questionText: "How do Kotlin coroutines work, and how are they used in Android development?",
    idealAnswer: "Kotlin coroutines are a concurrency framework that allows you to write asynchronous, non-blocking code in a sequential style using suspend functions, which can pause execution without blocking the thread and resume later. In Android, coroutines are structured around CoroutineScope, which defines the lifecycle of coroutines: viewModelScope in ViewModels automatically cancels when the ViewModel is cleared, and lifecycleScope in Activities/Fragments cancels when the lifecycle is destroyed. You launch coroutines with launch for fire-and-forget operations or async for operations that return a result via a Deferred object. Dispatchers control which thread the coroutine runs on: Dispatchers.Main for UI updates, Dispatchers.IO for network and database operations, and Dispatchers.Default for CPU-intensive work; withContext switches between dispatchers within a coroutine. Coroutines integrate with Flow for reactive streams, Room for database queries, and Retrofit for network calls, making them the standard approach for async operations in modern Android development.",
    category: "Android Development",
    difficulty: "MEDIUM" as const,
    tags: ["kotlin", "android", "coroutines", "async", "concurrency"],
  },
  {
    questionText: "What is the difference between a Fragment and an Activity in Android?",
    idealAnswer: "An Activity represents a single screen with a user interface and serves as the entry point for user interaction, while a Fragment is a modular, reusable portion of UI that exists within an Activity and has its own lifecycle that is directly tied to its host Activity's lifecycle. Fragments were introduced to support flexible UI layouts, particularly for tablets where you might show a list and detail view side by side in one Activity, while phones would use separate screens. Each Fragment has lifecycle callbacks similar to an Activity (onCreateView, onViewCreated, onResume, etc.) but also includes fragment-specific callbacks like onAttach and onDetach for managing the connection to the host Activity. Modern Android development using the single-Activity architecture pattern uses one Activity as a container with a NavHostFragment managing navigation between multiple Fragments using the Navigation component. Fragments communicate with each other through shared ViewModels, the Fragment Result API, or through their parent Activity, rather than directly referencing each other.",
    category: "Android Development",
    difficulty: "EASY" as const,
    tags: ["kotlin", "android", "fragments", "activities", "navigation"],
  },
  {
    questionText: "Explain Android's ViewModel and how it survives configuration changes.",
    idealAnswer: "ViewModel is a Jetpack component designed to store and manage UI-related data in a lifecycle-conscious way, surviving configuration changes like screen rotations that would normally destroy and recreate an Activity or Fragment. Internally, ViewModels are stored in a ViewModelStore that is retained by the Activity's NonConfigurationInstance mechanism, which the system preserves across configuration-triggered destruction and recreation cycles. You obtain a ViewModel through ViewModelProvider or the by viewModels() Kotlin delegate, and the same instance is returned to the new Activity/Fragment after recreation, preserving all in-memory data without needing to serialize it. ViewModels should not hold references to Activities, Fragments, or Views to avoid memory leaks, since they outlive these components; instead, they expose data through LiveData, StateFlow, or Compose state that the UI layer observes. The ViewModel's onCleared method is called when the associated Activity is truly finishing (not just rotating), making it the right place to cancel coroutines and clean up resources.",
    category: "Android Development",
    difficulty: "MEDIUM" as const,
    tags: ["kotlin", "android", "viewmodel", "jetpack", "architecture"],
  },
  {
    questionText: "What is Dagger Hilt, and how does it simplify dependency injection in Android?",
    idealAnswer: "Dagger Hilt is a dependency injection library built on top of Dagger 2 that provides a standard way to incorporate DI into Android applications with reduced boilerplate and pre-defined component hierarchies. It simplifies Dagger by automatically generating components tied to Android lifecycle classes: @HiltAndroidApp for the Application, @AndroidEntryPoint for Activities and Fragments, and @HiltViewModel for ViewModels, eliminating the need to manually create and manage Dagger components. Dependencies are provided through @Module classes with @Provides or @Binds methods, and scoped using annotations like @Singleton, @ActivityScoped, or @ViewModelScoped that automatically follow Android lifecycle management. Hilt integrates seamlessly with other Jetpack libraries, particularly ViewModel injection using @HiltViewModel and @Inject constructor, and supports testing through @HiltAndroidTest with the ability to replace bindings using @TestInstallIn or @UninstallModules. This standardized approach means every Hilt-enabled Android project follows the same DI patterns, making codebases more maintainable and reducing the learning curve.",
    category: "Android Development",
    difficulty: "HARD" as const,
    tags: ["kotlin", "android", "hilt", "dagger", "dependency-injection"],
  },
  {
    questionText: "How does Room database work in Android, and what are its core components?",
    idealAnswer: "Room is Android's Jetpack persistence library that provides an abstraction layer over SQLite, offering compile-time verification of SQL queries and seamless integration with Kotlin coroutines and Flow. Its three core components are: @Entity (defines database tables as Kotlin data classes with annotations for primary keys, indices, and foreign keys), @Dao (Data Access Object interfaces defining database operations with annotated methods like @Insert, @Update, @Delete, and @Query), and @Database (an abstract class extending RoomDatabase that lists entities and provides DAO instances). Room validates SQL queries at compile time, catching errors before runtime, and supports type converters for complex data types, database migrations for schema changes, and pre-populated databases from assets. It integrates naturally with coroutines by supporting suspend functions and Flow return types in DAOs, enabling reactive UI updates when data changes, and works with Hilt for dependency injection of the database and DAO instances.",
    category: "Android Development",
    difficulty: "MEDIUM" as const,
    tags: ["kotlin", "android", "room", "database", "sqlite", "jetpack"],
  },
  {
    questionText: "What is the Android Gradle build system, and how do build variants and product flavors work?",
    idealAnswer: "Android uses Gradle as its build system with the Android Gradle Plugin (AGP) providing Android-specific build tasks like APK packaging, resource merging, ProGuard/R8 code shrinking, and signing. Build types (typically debug and release) define how the app is compiled and packaged, with debug including debugging symbols and release enabling code optimization and minification. Product flavors allow you to create different versions of your app from a single codebase, such as a free and paid version or versions for different markets, each with unique application IDs, resources, and source sets. The combination of build types and product flavors creates build variants (e.g., freeDebug, paidRelease), and each variant can have its own source directory for variant-specific code and resources. The build.gradle.kts (or .groovy) files configure dependencies, SDK versions, signing configs, and custom build logic, with Gradle's dependency resolution managing transitive dependencies and version conflicts through the implementation, api, and compileOnly configurations.",
    category: "Android Development",
    difficulty: "HARD" as const,
    tags: ["kotlin", "android", "gradle", "build-system", "product-flavors"],
  },
  {
    questionText: "Explain how WorkManager works in Android and when you would use it over other background processing solutions.",
    idealAnswer: "WorkManager is a Jetpack library for scheduling deferrable, guaranteed background work that is expected to run even if the app exits or the device restarts, using the best available implementation (JobScheduler on API 23+, or a combination of BroadcastReceiver and AlarmManager on older versions). You define work by extending the Worker or CoroutineWorker class, create a WorkRequest (OneTimeWorkRequest or PeriodicWorkRequest) with optional constraints like requiring network connectivity or sufficient battery, and enqueue it with WorkManager. It supports work chaining where tasks execute sequentially or in parallel, input/output data passing between chained workers, and unique work policies to handle duplicate requests. WorkManager should be used for tasks that must complete reliably, such as uploading logs, syncing data, or processing images; it should not be used for immediate, in-process work (use coroutines) or exact-time tasks (use AlarmManager with exact alarms). Work status is observable through LiveData or Flow, enabling the UI to display progress, and work can be tagged for batch cancellation or status queries.",
    category: "Android Development",
    difficulty: "HARD" as const,
    tags: ["kotlin", "android", "workmanager", "background-processing", "jetpack"],
  },

  // ==================== JavaScript (10 questions) ====================
  {
    questionText: "What is the difference between var, let, and const in JavaScript?",
    idealAnswer: "var declares a function-scoped variable that is hoisted to the top of its function (initialized as undefined), can be redeclared, and is accessible before its declaration line due to hoisting. let declares a block-scoped variable that exists only within the nearest enclosing curly braces, cannot be redeclared in the same scope, and throws a ReferenceError if accessed before declaration (temporal dead zone). const is also block-scoped like let but requires an initial value and prevents reassignment of the variable binding, though it does not make objects or arrays immutable (their properties and elements can still be modified). In modern JavaScript and mobile development with React Native, the best practice is to use const by default and let only when you need to reassign a variable, while avoiding var entirely to prevent scoping bugs and hoisting confusion.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["javascript", "variables", "scope", "es6", "fundamentals"],
  },
  {
    questionText: "Explain JavaScript closures and provide a practical use case in mobile development.",
    idealAnswer: "A closure is a function that retains access to its lexical scope's variables even after the outer function has finished executing, effectively 'closing over' those variables and keeping them alive in memory. This works because when a function is created, it captures a reference to its surrounding environment (the scope chain), and as long as the inner function exists, those variables cannot be garbage collected. In mobile development, closures are commonly used in event handlers and callbacks, such as setting up a button press handler that remembers which item in a list it corresponds to, or creating private state in custom hooks. A practical example is a debounce function for search input in a mobile app: the closure preserves the timer reference between calls, canceling the previous timeout each time the user types and only executing the search after they stop typing. Closures also form the foundation of React hooks like useState, where the state value is preserved between renders through closure over the component's fiber.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["javascript", "closures", "scope", "react-native", "functional-programming"],
  },
  {
    questionText: "How does the JavaScript event loop work, and why is it important for mobile apps?",
    idealAnswer: "The JavaScript event loop is the mechanism that allows JavaScript to perform non-blocking operations despite being single-threaded, by offloading tasks to the browser or runtime environment and processing their results through a callback queue. The event loop continuously checks if the call stack is empty, and when it is, it first processes all microtasks (Promise callbacks, queueMicrotask) from the microtask queue, then takes the next macrotask (setTimeout, setInterval, I/O callbacks) from the task queue and pushes it onto the call stack. In mobile apps, understanding the event loop is critical because long-running synchronous operations on the JavaScript thread will block UI updates and cause the app to appear frozen or janky. React Native runs JavaScript on a separate thread from the main UI thread, but within that JS thread, the same event loop rules apply, so expensive computations should be broken up using techniques like InteractionManager.runAfterInteractions or moved to a separate thread using worker threads. Proper management of asynchronous operations, Promise chains, and avoiding blocking the event loop directly impacts the perceived performance and responsiveness of mobile applications.",
    category: "Mobile Architecture",
    difficulty: "HARD" as const,
    tags: ["javascript", "event-loop", "async", "performance", "react-native"],
  },
  {
    questionText: "What are Promises in JavaScript, and how do they improve asynchronous code?",
    idealAnswer: "A Promise is an object representing the eventual completion or failure of an asynchronous operation, existing in one of three states: pending (initial state), fulfilled (operation completed successfully), or rejected (operation failed). Promises improve asynchronous code over callbacks by providing a chainable .then() and .catch() API that avoids deeply nested callback hell, and they guarantee that handlers are called asynchronously even if the Promise is already resolved. Promise.all executes multiple promises concurrently and resolves when all complete (failing fast on any rejection), Promise.allSettled waits for all to finish regardless of outcome, Promise.race resolves with the first settled promise, and Promise.any resolves with the first fulfilled promise. Combined with async/await syntax, Promises allow you to write asynchronous code that reads linearly like synchronous code, with try/catch for error handling. In mobile development, Promises are used extensively for API calls, file system operations, database queries, and any operation that shouldn't block the UI thread.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["javascript", "promises", "async", "error-handling", "fundamentals"],
  },
  {
    questionText: "Explain the concept of prototypal inheritance in JavaScript and how it differs from classical inheritance.",
    idealAnswer: "Prototypal inheritance in JavaScript means that objects inherit directly from other objects through a prototype chain, rather than from class blueprints as in classical inheritance languages like Java or C++. Every JavaScript object has an internal [[Prototype]] link (accessible via Object.getPrototypeOf or __proto__) pointing to another object, and when a property is accessed, the engine walks up this chain until it finds the property or reaches null. Unlike classical inheritance where classes define a fixed structure and instances are created from that template, prototypal inheritance is dynamic and allows objects to be modified at runtime, with changes to a prototype immediately reflected in all objects that inherit from it. The ES6 class syntax is syntactic sugar over prototypal inheritance, providing familiar class/extends keywords that compile down to prototype chain manipulation under the hood. Understanding this is important in mobile development because React component behavior, library method resolution, and JavaScript performance optimizations like hidden classes in V8 and Hermes all depend on how the prototype chain is structured.",
    category: "Mobile Architecture",
    difficulty: "HARD" as const,
    tags: ["javascript", "prototypal-inheritance", "oop", "es6", "fundamentals"],
  },
  {
    questionText: "What is destructuring in JavaScript, and how is it commonly used in React Native?",
    idealAnswer: "Destructuring is a JavaScript syntax that allows you to extract values from arrays or properties from objects into distinct variables in a concise, readable way. Object destructuring uses curly braces to pull out named properties (const { name, age } = user), while array destructuring uses square brackets based on position (const [first, second] = items), and both support default values, renaming, nested destructuring, and rest patterns. In React Native, destructuring is used extensively: extracting props in component definitions (function Card({ title, subtitle, onPress })), unpacking hook returns (const [state, setState] = useState()), accessing nested navigation params, and pulling specific methods from imported modules. It also works in function parameters to create clear, self-documenting APIs and in import statements to selectively import named exports. Destructuring improves code readability by making it immediately clear which values from an object or array are being used in a given context.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["javascript", "destructuring", "es6", "react-native", "syntax"],
  },
  {
    questionText: "How does TypeScript enhance JavaScript for mobile development, and what are its key features?",
    idealAnswer: "TypeScript is a statically-typed superset of JavaScript that adds compile-time type checking, interfaces, generics, and other features that catch errors before runtime, which is especially valuable in mobile development where runtime crashes lead to poor user experience. Key features include type annotations for variables and function signatures, interfaces and type aliases for defining complex object shapes, generics for reusable typed components and hooks, enums for constant sets, and union/intersection types for flexible type composition. In React Native, TypeScript enables strong typing of component props (preventing incorrect prop passing), typed navigation parameters (catching incorrect route names at compile time), typed API response shapes, and typed Redux/Zustand store actions and state. The TypeScript compiler also provides superior IDE support with autocompletion, refactoring tools, and inline documentation. Most modern React Native projects use TypeScript by default, and the React Native CLI and Expo both provide TypeScript templates out of the box.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["typescript", "javascript", "react-native", "type-safety", "mobile-development"],
  },
  {
    questionText: "Explain the spread operator and rest parameters in JavaScript with mobile development examples.",
    idealAnswer: "The spread operator (...) expands an iterable (array, object, or string) into individual elements, while rest parameters collect multiple arguments into a single array, both using the same three-dot syntax but in different contexts. The spread operator is used to shallow-copy and merge objects (const updated = { ...state, loading: true }), clone arrays ([...items]), and pass array elements as function arguments (Math.max(...numbers)). Rest parameters gather remaining function arguments (function log(first, ...rest)) and are used in destructuring to collect leftover properties (const { id, ...otherProps } = user). In React Native, spread is essential for immutable state updates in Redux or useState, passing props to child components ({...props}), merging styles ({...StyleSheet.flatten(baseStyle), ...overrides}), and combining configuration objects. The spread operator performs a shallow copy, so nested objects still share references, which is important to understand when working with complex state management in mobile apps.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["javascript", "spread-operator", "rest-parameters", "es6", "react-native"],
  },
  {
    questionText: "What is the difference between map, filter, and reduce in JavaScript, and when do you use each?",
    idealAnswer: "map, filter, and reduce are array methods that enable functional data transformation without mutating the original array, each serving a distinct purpose. map transforms each element in an array and returns a new array of the same length with transformed values, commonly used in React Native to convert data arrays into component arrays for rendering lists. filter creates a new array containing only elements that pass a provided test function, returning a subset of the original array; it is used for search filtering, removing items, or displaying conditional data. reduce iterates over the array and accumulates a single value (which can be a number, string, object, or another array), making it the most versatile but also most complex; it is used for summing values, grouping data, flattening nested arrays, or building lookup objects. These methods can be chained together (data.filter().map()) for expressive data pipelines, and in mobile development they are fundamental for processing API responses, transforming state for display, and computing derived values in selectors.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["javascript", "array-methods", "functional-programming", "data-transformation"],
  },
  {
    questionText: "What are JavaScript modules (ESM vs CommonJS), and how do they affect mobile app bundling?",
    idealAnswer: "JavaScript modules allow code to be organized into separate files that export and import functionality, with two main systems: CommonJS (CJS) using require() and module.exports for synchronous loading in Node.js, and ECMAScript Modules (ESM) using import/export syntax with static analysis capabilities. ESM is the modern standard adopted by React Native and most mobile frameworks, supporting tree-shaking where bundlers like Metro (React Native) or webpack can statically analyze imports and remove unused code from the final bundle. CommonJS modules are dynamically evaluated, meaning imports are resolved at runtime, making it impossible for bundlers to determine which exports are actually used, leading to larger bundle sizes. Metro, React Native's bundler, processes ESM imports to create an optimized JavaScript bundle, resolving platform-specific files (.ios.js, .android.js), handling asset imports (images, fonts), and supporting features like Fast Refresh. Understanding modules is critical for mobile performance because bundle size directly impacts app download size and startup time, and properly structured module boundaries enable code splitting and lazy loading.",
    category: "Mobile Architecture",
    difficulty: "HARD" as const,
    tags: ["javascript", "modules", "esm", "commonjs", "bundling", "metro"],
  },

  // ==================== Git (10 questions) ====================
  {
    questionText: "What is Git, and why is it essential for mobile development teams?",
    idealAnswer: "Git is a distributed version control system that tracks changes in source code, allowing developers to maintain a complete history of modifications, collaborate on shared codebases, and manage multiple development streams simultaneously. For mobile development teams, Git is essential because it enables parallel feature development through branching (multiple developers can work on different features without conflicts), provides a safety net to revert breaking changes that could cause app crashes, and maintains audit trails for app store review requirements. Its distributed nature means every developer has a full copy of the repository, enabling offline work and reducing single points of failure. Git integrates with CI/CD pipelines for automated building, testing, and deployment of mobile apps, and platforms like GitHub and GitLab add code review workflows through pull requests that are critical for maintaining code quality in production mobile applications.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["git", "version-control", "collaboration", "mobile-development"],
  },
  {
    questionText: "Explain the difference between git merge and git rebase, and when you would use each.",
    idealAnswer: "Git merge combines two branches by creating a new merge commit that has two parents, preserving the complete branching history and showing exactly when and how branches diverged and were integrated. Git rebase replays commits from one branch onto the tip of another, rewriting commit history to create a linear sequence as if the changes were made on top of the target branch all along. Merge is preferred for shared branches and integration of feature branches into main/develop because it preserves the true collaborative history and is non-destructive; rebase is preferred for updating a personal feature branch with the latest changes from main to maintain a clean, linear history before merging. The golden rule is to never rebase commits that have been pushed to a shared remote branch, as this rewrites history and forces collaborators to reconcile divergent histories. In mobile development workflows, a common approach is to rebase feature branches locally, then use a merge (often via pull request) to integrate into the main branch, providing both a clean feature branch history and clear merge points.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["git", "merge", "rebase", "branching", "workflow"],
  },
  {
    questionText: "How do you resolve merge conflicts in Git, and what strategies prevent them?",
    idealAnswer: "Merge conflicts occur when Git cannot automatically merge changes because two branches modified the same lines in a file, and they are resolved by manually editing the conflicted files to choose the correct content between the <<<<<<< HEAD, =======, and >>>>>>> markers, then staging the resolved files and completing the merge. You can use git mergetool to open a visual merge tool, or resolve conflicts directly in your IDE which typically highlights conflicts and provides accept-current, accept-incoming, and accept-both options. Strategies to prevent conflicts include: keeping branches short-lived and merging frequently, breaking large files into smaller modules to reduce overlap, communicating with team members about shared file changes, and using clear code ownership patterns. In mobile development, conflicts commonly occur in generated files like Xcode project files (.pbxproj), Android Gradle files, or package lock files; using tools like xcodegen or Tuist to generate project files and gitattributes to define merge strategies for specific file types can help. Regular pulling from the shared branch and rebasing feature branches keeps them current and minimizes the scope of potential conflicts.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["git", "merge-conflicts", "conflict-resolution", "collaboration"],
  },
  {
    questionText: "What is a Git branching strategy, and describe Git Flow vs trunk-based development for mobile teams.",
    idealAnswer: "A Git branching strategy defines rules for how branches are created, named, merged, and deleted in a repository, providing structure for team collaboration and release management. Git Flow uses long-lived branches (main, develop, feature/*, release/*, hotfix/*) where features branch from develop, are merged back after review, release branches are cut for stabilization, and main always reflects production; this works well for mobile apps with fixed release cycles tied to app store submissions. Trunk-based development keeps a single main branch where developers commit frequently (at least daily) using short-lived feature branches or direct commits, relying on feature flags to hide incomplete work; this suits teams practicing continuous delivery. For mobile development, Git Flow's structured releases align well with the app store review and release process, while trunk-based development works better for teams using over-the-air updates (like CodePush) or rapid iteration cycles. Many mobile teams adopt a hybrid approach, using trunk-based development for daily work but creating release branches when preparing app store submissions to allow hotfixes without including in-progress features.",
    category: "Mobile Architecture",
    difficulty: "HARD" as const,
    tags: ["git", "branching-strategy", "gitflow", "trunk-based", "workflow"],
  },
  {
    questionText: "How does git stash work, and when would you use it in a mobile development workflow?",
    idealAnswer: "Git stash temporarily saves uncommitted changes (both staged and unstaged) to a stack-like structure, reverting your working directory to a clean state without creating a commit. You use git stash to save changes, git stash list to view saved stashes, git stash pop to apply and remove the most recent stash, and git stash apply to apply without removing it. In mobile development, stashing is useful when you need to quickly switch branches to fix a production bug while in the middle of feature work, when you want to test the clean state of a branch before committing, or when you need to pull remote changes that conflict with your local modifications. You can create named stashes with git stash save \"description\" or git stash push -m \"description\" for better organization, and selectively stash specific files using git stash push path/to/file. The git stash branch command is particularly useful when you realize your stashed changes should go on a different branch, automatically creating a new branch from the stash point and applying the changes.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["git", "stash", "workflow", "mobile-development"],
  },
  {
    questionText: "What are Git hooks, and how can they be used to improve mobile app code quality?",
    idealAnswer: "Git hooks are scripts that Git executes automatically before or after specific events like committing, pushing, or merging, stored in the .git/hooks directory. In mobile development, pre-commit hooks can run linters (ESLint for React Native, SwiftLint for iOS, ktlint for Android) and formatters (Prettier) to enforce code style before changes are committed, preventing style-related review comments. Pre-push hooks can run the test suite to catch failures before code reaches the remote repository, which is especially valuable for mobile apps where certain bugs only surface on specific platforms. Tools like Husky (for JavaScript/React Native projects) and lint-staged make it easy to configure hooks that run only on changed files, keeping execution fast. Commit-msg hooks can enforce commit message conventions (like Conventional Commits) that enable automated changelog generation and semantic versioning for app releases. Server-side hooks (pre-receive, post-receive) on platforms like GitHub are implemented through CI/CD checks and protected branch rules, ensuring no code reaches main without passing build and test requirements.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["git", "hooks", "code-quality", "ci-cd", "linting"],
  },
  {
    questionText: "Explain git cherry-pick and describe a scenario where it is useful in mobile development.",
    idealAnswer: "Git cherry-pick applies the changes introduced by a specific commit from one branch onto your current branch, creating a new commit with a different hash but identical changes. The syntax is git cherry-pick <commit-hash>, and you can cherry-pick multiple commits, ranges of commits, or use --no-commit to apply changes without immediately committing. In mobile development, a common scenario is when a critical bug fix committed to a feature branch needs to be included in the current release branch without merging the entire feature: you cherry-pick just the fix commit onto the release branch. Another common use case is backporting security patches to older supported versions of your app, where the fix exists on the latest branch but needs to be applied to a maintenance branch for users who haven't updated. Cherry-pick should be used sparingly because it creates duplicate commits that can cause confusion during later merges; when possible, restructuring your workflow to avoid cherry-picking (such as making fixes on the oldest affected branch first and merging forward) leads to a cleaner history.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["git", "cherry-pick", "release-management", "hotfix"],
  },
  {
    questionText: "How do you use git bisect to find the commit that introduced a bug in a mobile app?",
    idealAnswer: "Git bisect performs a binary search through your commit history to efficiently find the exact commit that introduced a bug, reducing the search from O(n) to O(log n) commits. You start with git bisect start, then mark the current broken state with git bisect bad and a known working commit with git bisect good <commit-hash>; Git then checks out the midpoint commit for you to test. After testing each midpoint (building and running the app), you mark it as git bisect good or git bisect bad, and Git narrows the range by half until it identifies the first bad commit. This process can be automated with git bisect run <script> where the script exits with 0 for good and non-zero for bad, such as a test that reproduces the bug. In mobile development, bisect is invaluable for tracking down regressions like performance degradation, visual glitches, or crashes that appeared at some unknown point, especially in large teams where many commits land between releases. After finding the culprit commit, use git bisect reset to return to your original branch.",
    category: "Mobile Architecture",
    difficulty: "HARD" as const,
    tags: ["git", "bisect", "debugging", "regression", "mobile-development"],
  },
  {
    questionText: "What is the difference between git pull and git fetch?",
    idealAnswer: "Git fetch downloads new commits, branches, and tags from a remote repository into your local repository's remote-tracking branches (like origin/main) without modifying your working directory or local branches, allowing you to review changes before integrating them. Git pull is essentially git fetch followed by git merge (or git rebase if configured), automatically integrating the remote changes into your current local branch. The key distinction is safety: fetch lets you inspect incoming changes with git log origin/main or git diff main..origin/main before deciding how to incorporate them, while pull immediately merges, which can result in unexpected merge commits or conflicts. Best practice in mobile development teams is to use git fetch followed by a deliberate merge or rebase, especially before starting new work, so you understand what changes teammates have pushed. You can configure git pull to rebase by default with git config --global pull.rebase true, which prevents unnecessary merge commits and keeps a cleaner history on feature branches.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["git", "pull", "fetch", "remote", "fundamentals"],
  },
  {
    questionText: "How do you manage large binary assets like images and fonts in a Git repository for a mobile app?",
    idealAnswer: "Large binary assets in a mobile app's Git repository can bloat the repository size because Git stores full copies of binaries rather than efficient diffs, making clones and fetches increasingly slow over time. Git Large File Storage (Git LFS) solves this by replacing large files with lightweight pointer files in the repository while storing the actual file content on a separate LFS server; you configure it with git lfs track \"*.png\" and it transparently handles downloads on checkout. For mobile-specific assets, you can use .gitattributes to track image assets (PNG, JPG), design files, video assets, and font files through LFS while keeping source code in regular Git. Another approach is to use a content delivery network (CDN) or asset management service and download assets at build time or runtime, keeping only references in the repository. Best practices include compressing images before committing (using tools like ImageOptim or svgo), generating different resolution assets during the build process rather than storing multiple versions, and regularly auditing the repository with tools like git-sizer to identify unexpected binary bloat.",
    category: "Mobile Architecture",
    difficulty: "HARD" as const,
    tags: ["git", "git-lfs", "binary-assets", "repository-management", "mobile-development"],
  },

  // ==================== Flutter (10 questions) ====================
  {
    questionText: "What is Flutter, and how does its architecture differ from other cross-platform frameworks?",
    idealAnswer: "Flutter is Google's open-source UI toolkit for building natively compiled applications for mobile, web, and desktop from a single Dart codebase, using a custom rendering engine rather than platform-native UI components. Unlike React Native which bridges to native components or Ionic which runs in a WebView, Flutter draws every pixel on screen using its own Skia-based (now Impeller on iOS) rendering engine, giving it complete control over the appearance and behavior of every widget across platforms. Flutter's architecture consists of three layers: the Framework layer (written in Dart, providing widgets, animation, and gesture APIs), the Engine layer (written in C++, handling rendering, text layout, and platform channels), and the Embedder layer (platform-specific code that hosts the engine). This approach means Flutter widgets look identical across platforms by default (though platform-adaptive widgets are available), compilation to native ARM code provides near-native performance, and the hot reload feature allows sub-second UI iteration during development.",
    category: "Cross-Platform Development",
    difficulty: "EASY" as const,
    tags: ["flutter", "dart", "cross-platform", "architecture", "rendering"],
  },
  {
    questionText: "Explain the difference between StatelessWidget and StatefulWidget in Flutter.",
    idealAnswer: "A StatelessWidget is an immutable widget that describes part of the UI based solely on its constructor parameters and the build context, rebuilding only when its parent provides new configuration; examples include Text, Icon, and custom display-only widgets. A StatefulWidget has an associated State object that persists across rebuilds and can hold mutable data that changes over the widget's lifetime, triggering UI updates when setState() is called. The State object's lifecycle includes initState (called once for initialization), build (called whenever the state changes or the widget is rebuilt), didUpdateWidget (when the parent provides new configuration), and dispose (for cleanup when removed from the tree). The separation of Widget (immutable configuration) and State (mutable state) is a key Flutter design decision: widgets are lightweight and frequently recreated, while State objects persist and maintain the actual data. Best practice is to prefer StatelessWidget and move state management to dedicated solutions (Provider, Riverpod, BLoC) as app complexity grows, using StatefulWidget mainly for local, ephemeral UI state like form inputs or animation controllers.",
    category: "Cross-Platform Development",
    difficulty: "EASY" as const,
    tags: ["flutter", "dart", "widgets", "state-management", "fundamentals"],
  },
  {
    questionText: "How does Flutter's widget tree and rendering pipeline work?",
    idealAnswer: "Flutter maintains three parallel trees: the Widget tree (lightweight, immutable configuration objects rebuilt frequently), the Element tree (persistent objects that manage the lifecycle and link widgets to render objects), and the RenderObject tree (handles layout, painting, and hit testing). When setState is called, Flutter marks the element as dirty, and during the next frame, the build phase walks the dirty elements, calling their build methods to produce new widgets that are reconciled with the existing element tree (similar to React's virtual DOM diffing). The layout phase traverses the render tree in a single pass, with parent render objects passing constraints down and children returning their sizes up, following the constraint-based layout model. The paint phase composites render objects onto layers, which are compiled into a scene and submitted to the Skia (or Impeller) engine for GPU rendering at up to 120fps. This architecture enables Flutter's high performance because the framework only rebuilds and repaints what has changed, and the entire rendering pipeline runs in compiled native code without crossing any bridge to the platform.",
    category: "Cross-Platform Development",
    difficulty: "HARD" as const,
    tags: ["flutter", "dart", "rendering", "widget-tree", "performance"],
  },
  {
    questionText: "What is the BLoC pattern in Flutter, and how does it manage state?",
    idealAnswer: "BLoC (Business Logic Component) is a state management pattern in Flutter that separates business logic from the presentation layer using reactive streams, where UI components dispatch events to a BLoC and listen to state changes through streams. The pattern consists of Events (user actions or system triggers sent to the BLoC), the BLoC itself (processes events and emits new states through a Stream), and States (immutable objects representing the UI state at a given moment). Using the flutter_bloc package, you create a Bloc class that extends Bloc<Event, State>, register event handlers with on<EventType>, and emit new states; BlocProvider injects the BLoC into the widget tree, and BlocBuilder/BlocListener/BlocConsumer widgets react to state changes. BLoC promotes testability because business logic is pure Dart with no Flutter dependencies, and events/states are easily mockable. The pattern works particularly well for complex features like authentication flows, form validation, and data synchronization where the business logic needs to be clearly separated and independently tested.",
    category: "Cross-Platform Development",
    difficulty: "MEDIUM" as const,
    tags: ["flutter", "dart", "bloc", "state-management", "reactive"],
  },
  {
    questionText: "How do you handle navigation and routing in a Flutter application?",
    idealAnswer: "Flutter provides both imperative (Navigator 1.0) and declarative (Navigator 2.0/Router) navigation APIs for managing screen transitions. Navigator 1.0 uses a stack-based approach with Navigator.push to add routes and Navigator.pop to remove them, supporting named routes defined in MaterialApp's routes map or onGenerateRoute callback. Navigator 2.0 (Router API) provides declarative, URL-based routing that integrates with the browser's address bar for web apps and supports deep linking on mobile, using a RouterDelegate and RouteInformationParser to map URLs to app state. In practice, most teams use routing packages like GoRouter (maintained by the Flutter team) or auto_route, which provide a simpler API over Navigator 2.0 with features like path parameters, query parameters, redirects, guards, nested navigation, and bottom navigation bar integration. Navigation state can be persisted to handle deep links from push notifications, share URLs, and restore the user's position when the app is killed and relaunched.",
    category: "Cross-Platform Development",
    difficulty: "MEDIUM" as const,
    tags: ["flutter", "dart", "navigation", "routing", "deep-linking"],
  },
  {
    questionText: "Explain how platform channels work in Flutter for accessing native APIs.",
    idealAnswer: "Platform channels are Flutter's mechanism for communicating between Dart code and platform-specific native code (Swift/Objective-C on iOS, Kotlin/Java on Android) using asynchronous message passing. The three types are MethodChannel (for method calls returning a one-time result), EventChannel (for streaming data from native to Dart, like sensor updates), and BasicMessageChannel (for bidirectional message passing with custom codecs). You create a MethodChannel with a unique string name on both the Dart and native sides, invoke methods from Dart using channel.invokeMethod, and handle them natively by setting a method call handler that processes the method name and arguments. Messages are serialized using the StandardMessageCodec (supporting null, bool, int, double, String, List, Map, and byte data) and passed asynchronously through the platform thread. For commonly needed platform APIs, Flutter has a rich ecosystem of platform plugins (camera, sensors, biometrics) that wrap platform channels, and the Pigeon package can generate type-safe platform channel code from a Dart interface definition.",
    category: "Cross-Platform Development",
    difficulty: "HARD" as const,
    tags: ["flutter", "dart", "platform-channels", "native-api", "interop"],
  },
  {
    questionText: "What is the Dart programming language, and what features make it suitable for Flutter?",
    idealAnswer: "Dart is an object-oriented, class-based language developed by Google that compiles to native ARM/x64 code for mobile, JavaScript for web, and runs on a VM for development, making it the foundation of Flutter's cross-platform capabilities. Key features that make Dart ideal for Flutter include: ahead-of-time (AOT) compilation producing fast native code for production and just-in-time (JIT) compilation enabling hot reload during development, sound null safety that eliminates null reference errors at compile time, and an async/await model with Futures and Streams built into the language. Dart's single-threaded event loop with isolates for CPU-intensive work maps well to UI programming, where the main isolate handles rendering and user input without interference from background computation. The language supports rich type inference, mixins for code reuse across class hierarchies, extension methods for adding functionality to existing types, and a comprehensive standard library. Dart's garbage collector is optimized for UI workloads with generational collection and idle-time GC scheduling that minimizes frame drops.",
    category: "Cross-Platform Development",
    difficulty: "EASY" as const,
    tags: ["flutter", "dart", "programming-language", "compilation", "fundamentals"],
  },
  {
    questionText: "How does Flutter's hot reload work, and what are its limitations?",
    idealAnswer: "Flutter's hot reload injects updated Dart source code into the running Dart VM, triggering the framework to rebuild the widget tree while preserving the current app state and navigation position, typically completing in under a second. It works by compiling only the changed Dart files into kernel format, sending the delta to the VM which updates the affected libraries, and then the framework calls build() on all live widgets to reflect the changes. Hot reload preserves State objects (the state of StatefulWidgets), global variables, and static fields, making it excellent for iterating on UI layout, styles, and minor logic changes. However, it has limitations: changes to main(), global variable initializers, static field initializers, and enum definitions require a full hot restart (which resets state). Changes to native code (platform channels, plugins), asset files, and the app's initialization logic also require a complete rebuild. Understanding these limitations helps developers structure their code to maximize hot reload effectiveness, such as avoiding complex initialization logic in global scope.",
    category: "Cross-Platform Development",
    difficulty: "MEDIUM" as const,
    tags: ["flutter", "dart", "hot-reload", "development-tools", "productivity"],
  },
  {
    questionText: "What are Keys in Flutter, and when should you use them?",
    idealAnswer: "Keys in Flutter are identifiers that the framework uses to preserve state and optimize the reconciliation of the widget tree when widgets are reordered, added, or removed within a collection. Without keys, Flutter matches widgets by their type and position in the tree, which can cause incorrect state preservation when items in a list are reordered (a common bug where list item state appears to 'swap'). ValueKey uses a specific value (like an ID) to identify widgets, ObjectKey uses object identity, UniqueKey generates a unique identifier each time (forcing recreation), and GlobalKey provides access to a widget's state from anywhere in the tree and preserves state across subtree moves. You should use keys whenever you have a dynamic list of widgets of the same type that can be reordered, removed, or inserted (like items in a ListView.builder), in AnimatedSwitcher to differentiate between incoming and outgoing widgets, and when you need to preserve state across tree restructuring. GlobalKeys should be used sparingly as they have a performance cost and create implicit global state, but they are necessary for scenarios like accessing a FormState to validate a form.",
    category: "Cross-Platform Development",
    difficulty: "HARD" as const,
    tags: ["flutter", "dart", "keys", "widget-tree", "state-preservation"],
  },
  {
    questionText: "How do you test Flutter applications, and what types of tests does Flutter support?",
    idealAnswer: "Flutter provides a comprehensive testing framework supporting three layers of tests: unit tests (testing individual functions, methods, and classes in isolation using the test package), widget tests (testing individual widgets by rendering them in a test environment using WidgetTester to pump widgets, find elements, and tap/scroll/enter text), and integration tests (testing the complete app on a real device or emulator using the integration_test package). Widget tests are a sweet spot unique to Flutter because they run fast without a device (using a headless rendering engine) while still testing actual widget behavior, layout, and interactions. The framework provides finder utilities (find.text, find.byType, find.byKey) for locating widgets and matcher utilities (findsOneWidget, findsNothing) for assertions. For state management, you can mock dependencies using packages like mockito or mocktail, and BLoC-based architectures are particularly testable since you can verify exact sequences of state emissions. Golden tests compare rendered widgets pixel-by-pixel against reference images, catching visual regressions automatically, and are especially useful for ensuring consistent UI across different platforms.",
    category: "Cross-Platform Development",
    difficulty: "MEDIUM" as const,
    tags: ["flutter", "dart", "testing", "widget-tests", "integration-tests"],
  },

  // ==================== Firebase (10 questions) ====================
  {
    questionText: "What is Firebase, and what services does it provide for mobile app development?",
    idealAnswer: "Firebase is Google's Backend-as-a-Service (BaaS) platform that provides a comprehensive suite of tools for building, improving, and growing mobile and web applications without managing server infrastructure. Core services include Firestore and Realtime Database for cloud-hosted NoSQL data storage with real-time synchronization, Authentication for user sign-in with email, social providers, and phone number, Cloud Storage for file uploads, Cloud Messaging (FCM) for push notifications, and Cloud Functions for serverless backend logic. Firebase also provides growth and quality tools including Analytics for user behavior tracking, Crashlytics for real-time crash reporting, Remote Config for dynamic app configuration without app updates, A/B Testing, and App Distribution for beta testing. The platform offers generous free tiers (Spark plan) and pay-as-you-go pricing (Blaze plan), SDKs for iOS, Android, Flutter, React Native, and web, and a unified console for monitoring all services.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["firebase", "baas", "cloud-services", "mobile-backend"],
  },
  {
    questionText: "Explain the difference between Firebase Firestore and Realtime Database, and when to use each.",
    idealAnswer: "Firebase Realtime Database is a JSON-based cloud database that synchronizes data in real-time across connected clients, storing data as one large JSON tree with simple read/write operations and security rules based on path patterns. Cloud Firestore is a more advanced document-oriented NoSQL database organized into collections and documents, supporting richer data types, more powerful queries (compound queries with multiple where clauses, array-contains, collection group queries), and automatic multi-region replication. Firestore is generally preferred for new projects because it scales automatically, supports offline persistence on both mobile platforms out of the box, allows more complex data modeling with subcollections, and charges based on document operations rather than bandwidth. Realtime Database is better suited for simpler data structures where you need very low-latency synchronization (like a chat or collaborative typing indicator) and its pricing model (based on storage and bandwidth) is more predictable for apps with frequent small updates. Many apps use both: Realtime Database for presence systems and live typing indicators, and Firestore for the main structured data storage.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["firebase", "firestore", "realtime-database", "nosql", "data-storage"],
  },
  {
    questionText: "How does Firebase Authentication work, and what sign-in methods does it support?",
    idealAnswer: "Firebase Authentication provides a complete identity solution that handles user registration, sign-in, and session management, issuing JWT tokens that can be verified by Firebase services and custom backends. It supports email/password authentication, phone number (SMS) verification, anonymous authentication (for guest users who can later link to a full account), and federated identity providers including Google, Apple, Facebook, Twitter, GitHub, and Microsoft. The authentication flow typically involves calling a sign-in method from the Firebase SDK, which returns a UserCredential containing the user's profile information and an ID token; the SDK automatically handles token refresh, session persistence across app restarts, and cross-device state synchronization. Firebase Auth integrates directly with Firestore and Realtime Database security rules through the auth variable, enabling row-level security like 'users can only read their own documents.' You can also use custom claims (set via Admin SDK) to implement role-based access control, and link multiple authentication methods to a single user account, allowing a user who signed up with email to later add Google sign-in.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["firebase", "authentication", "jwt", "sign-in", "identity"],
  },
  {
    questionText: "What is Firebase Cloud Messaging (FCM), and how do you implement push notifications in a mobile app?",
    idealAnswer: "Firebase Cloud Messaging is a cross-platform messaging service that lets you send push notifications and data messages to iOS, Android, and web clients at no cost, with reliable delivery even when the app is in the background or terminated. Implementation involves: registering the app with FCM to receive a device token (unique per app installation), sending this token to your backend server for storage, and using the FCM API or Firebase console to send messages targeting specific tokens, topics (pub/sub), or user segments. On Android, you extend FirebaseMessagingService to handle incoming messages, while on iOS you integrate with APNs (Apple Push Notification service) through Firebase's abstraction layer and request notification permissions from the user. Messages can be notification messages (automatically displayed by the system with a title and body), data messages (handled silently by the app for custom processing), or combined messages; data messages are ideal for triggering background data syncs or in-app UI updates. Advanced features include message scheduling, analytics integration to track notification open rates, and channel management on Android for user notification preferences.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["firebase", "fcm", "push-notifications", "messaging", "mobile"],
  },
  {
    questionText: "How do Firestore security rules work, and how do you write rules that protect user data?",
    idealAnswer: "Firestore security rules are server-enforced access control rules written in a custom language that evaluate every read and write operation against the database, denying access by default unless a matching rule explicitly allows it. Rules are structured to match document paths using wildcards (match /users/{userId}), and within each match block you define allow statements for specific operations (read, write, get, list, create, update, delete) with boolean conditions. The rules have access to the request object (containing auth info, request time, and incoming data), the resource object (the existing document being accessed), and helper functions like exists() and get() for querying other documents. A common pattern for protecting user data is: allow read, write: if request.auth != null && request.auth.uid == userId, ensuring only the authenticated owner can access their documents. Best practices include writing granular rules (separate create/update/delete instead of blanket write), validating incoming data types and required fields (request.resource.data.name is string), limiting query scope with list rules that require filters, and testing rules thoroughly using the Firebase Emulator Suite before deployment.",
    category: "Mobile Security",
    difficulty: "HARD" as const,
    tags: ["firebase", "firestore", "security-rules", "access-control", "data-protection"],
  },
  {
    questionText: "What is Firebase Crashlytics, and how does it help improve mobile app stability?",
    idealAnswer: "Firebase Crashlytics is a lightweight, real-time crash reporting tool that helps developers track, prioritize, and fix stability issues in their mobile applications. It automatically captures crash reports with detailed stack traces, device information (model, OS version, orientation, memory state), and the sequence of events (breadcrumbs) leading up to the crash, grouping related crashes into issues for easier triage. Crashlytics distinguishes between fatal crashes (app termination) and non-fatal exceptions that you manually log using recordError/recordException, providing a crash-free users percentage that serves as a key stability metric. You can add custom keys, log messages, and user identifiers to crash reports to provide context about the app state when the crash occurred, making reproduction and debugging significantly faster. Integration with Firebase Analytics enables tracking of crash impact on user engagement, and velocity alerts notify your team when a new issue is rapidly affecting users, helping you prioritize critical fixes for your next app update.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["firebase", "crashlytics", "crash-reporting", "stability", "monitoring"],
  },
  {
    questionText: "Explain Firebase Cloud Functions and how they extend mobile app capabilities.",
    idealAnswer: "Firebase Cloud Functions is a serverless compute service that lets you run backend code in response to events triggered by Firebase features and HTTPS requests, automatically scaling from zero to handle any load without managing servers. Functions can be triggered by Firestore document changes (onCreate, onUpdate, onDelete), Authentication events (user creation/deletion), Cloud Storage uploads, FCM topic subscriptions, scheduled times (cron), and direct HTTPS calls. Common mobile app use cases include: sending welcome emails when users register, processing payments through secure server-side APIs, validating and transforming data before writing to Firestore, resizing uploaded images, aggregating data across collections (like maintaining counters), and calling third-party APIs with secrets that shouldn't be in the client app. Functions run in a Node.js (or Python/Go) environment with the Firebase Admin SDK pre-configured for full access to Firebase services, bypassing security rules for trusted server-side operations. Cold start latency (the delay when a function hasn't been called recently) can impact mobile UX, so strategies like minimum instances, keeping functions lightweight, and using 2nd gen Cloud Functions with concurrency support help mitigate this.",
    category: "Mobile Architecture",
    difficulty: "HARD" as const,
    tags: ["firebase", "cloud-functions", "serverless", "backend", "event-driven"],
  },
  {
    questionText: "How does Firebase Remote Config work, and what are its use cases in mobile apps?",
    idealAnswer: "Firebase Remote Config is a cloud service that lets you change the behavior and appearance of your mobile app without publishing an app update, by storing key-value parameters on the Firebase server that the app fetches at runtime. You define default values in the app, set server-side values in the Firebase console or via the Admin API, and the SDK fetches, caches, and activates these values with configurable fetch intervals (minimum 12-hour cache for production, real-time for development). Use cases include: A/B testing different UI layouts or copy to optimize conversion, gradually rolling out new features to a percentage of users (feature flags), adjusting difficulty levels or content in apps, changing promotional banners or seasonal themes, and configuring technical parameters like API endpoints or cache durations. Remote Config integrates with Firebase A/B Testing to run experiments comparing different parameter values against metrics like retention and revenue. Conditions allow targeting specific user segments based on app version, platform, country, user property, or random percentile, enabling sophisticated rollout strategies like launching a feature to 10% of Android users in a specific region first.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["firebase", "remote-config", "feature-flags", "a-b-testing", "configuration"],
  },
  {
    questionText: "What is Firebase App Distribution, and how does it streamline mobile app testing?",
    idealAnswer: "Firebase App Distribution is a service that allows you to distribute pre-release versions of your iOS and Android apps to trusted testers without going through app store review processes, replacing the complexity of TestFlight (for iOS) and ad-hoc APK distribution. Testers receive email or in-app invitations, can install new builds directly from a web clip (iOS) or download link (Android), and are notified when new builds are available. It integrates with CI/CD pipelines through the Firebase CLI, Gradle plugin (Android), and Fastlane plugin, enabling automatic distribution of every build from your continuous integration system. You can organize testers into groups (QA team, stakeholders, beta users), add release notes to each build, and track which testers have accepted invitations and installed specific versions. For iOS, it handles the complexity of provisioning profile management by supporting ad-hoc and enterprise distribution, and the in-app feedback SDK allows testers to submit screenshots and feedback directly from the test build. This streamlines the development cycle by getting builds into testers' hands within minutes of a commit, rather than waiting for app store processing.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["firebase", "app-distribution", "testing", "ci-cd", "beta-testing"],
  },
  {
    questionText: "How do you handle offline data persistence with Firebase Firestore in a mobile app?",
    idealAnswer: "Firestore provides built-in offline persistence that is enabled by default on mobile platforms, caching a copy of every document the app has queried locally so reads can be served from cache when the device has no network connection. When offline, writes are queued in a local persistence layer and automatically synchronized to the server when connectivity is restored, with the SDK handling conflict resolution using a last-write-wins strategy at the field level. The app can listen to real-time snapshots that include a metadata.hasPendingWrites flag indicating whether the data has been confirmed by the server, and metadata.isFromCache indicating the data source, allowing the UI to display sync status indicators. To optimize offline behavior, use query cursors and pagination to limit the cache size, implement cache-size limits (default is 100MB, configurable), and structure your data to minimize the number of documents needed for offline viewing. For scenarios requiring more complex offline logic (like custom conflict resolution or offline-first architecture), you may combine Firestore with local databases like SQLite/Room/Core Data, using Firestore listeners to sync when online and the local database as the single source of truth for the UI.",
    category: "Mobile Architecture",
    difficulty: "HARD" as const,
    tags: ["firebase", "firestore", "offline", "persistence", "synchronization"],
  },

  // ==================== Mobile UI Patterns (10 questions) ====================
  {
    questionText: "What are the key differences between Material Design and Human Interface Guidelines (HIG) for mobile apps?",
    idealAnswer: "Material Design (Google) and Human Interface Guidelines (Apple) are the two primary design systems for Android and iOS respectively, each reflecting the platform's philosophy and user expectations. Material Design emphasizes bold colors, elevation through shadows, floating action buttons, bottom navigation bars, and the concept of material surfaces that cast shadows and respond to touch with ripple effects. Apple's HIG focuses on clarity, deference, and depth, favoring navigation controllers with back buttons, tab bars at the bottom, large titles, translucent blurs, and subtle animations that feel connected to physical gestures. Key differences include navigation patterns (Android uses back button/gesture and top app bars; iOS uses swipe-from-edge and navigation bars), typography (Material uses Roboto; iOS uses San Francisco with Dynamic Type), and interaction patterns (Android has pull-to-refresh with a circular indicator; iOS uses a native spinner). When building cross-platform apps, the best practice is to follow each platform's conventions for maximum user familiarity while maintaining a consistent brand identity across both platforms.",
    category: "Mobile UI/UX",
    difficulty: "MEDIUM" as const,
    tags: ["material-design", "hig", "ui-patterns", "ios", "android", "design-systems"],
  },
  {
    questionText: "What is responsive design in mobile development, and how do you handle different screen sizes?",
    idealAnswer: "Responsive design in mobile development means creating layouts that adapt gracefully to different screen sizes, orientations, and pixel densities, from small phones to large tablets and foldable devices. Techniques include using flexible layouts (Flexbox in React Native, ConstraintLayout in Android, Auto Layout in iOS, Flex/Expanded in Flutter) that distribute space proportionally rather than using fixed pixel values. Media queries or dimension-based breakpoints allow you to render fundamentally different layouts for phone vs tablet (like a split-view master-detail on tablet and stacked views on phone). Safe area handling ensures content isn't obscured by notches, dynamic islands, home indicators, or rounded corners using SafeAreaView in React Native, safeAreaInset in iOS, or WindowInsets in Android. Best practices include testing on multiple device sizes using emulator profiles, using relative units (percentages, viewport units) instead of absolute pixels, designing for the smallest supported screen first (mobile-first), and leveraging platform APIs like useWindowDimensions in React Native or MediaQuery in Flutter to dynamically adapt layouts.",
    category: "Mobile UI/UX",
    difficulty: "MEDIUM" as const,
    tags: ["responsive-design", "screen-sizes", "layout", "adaptive-ui", "mobile-ui"],
  },
  {
    questionText: "Explain the concept of accessibility in mobile apps and key implementation practices.",
    idealAnswer: "Accessibility in mobile apps ensures that people with disabilities (visual, auditory, motor, and cognitive) can effectively use the application, and it is both an ethical obligation and often a legal requirement. Key implementation practices include: providing meaningful accessibility labels for all interactive elements so screen readers (VoiceOver on iOS, TalkBack on Android) can announce them, ensuring sufficient color contrast ratios (minimum 4.5:1 for normal text per WCAG), supporting Dynamic Type / font scaling so users with low vision can increase text size, and making all functionality accessible via keyboard and switch controls. Touch targets should meet minimum size guidelines (44x44pt on iOS, 48x48dp on Android), and important state changes should be announced to screen readers using accessibility announcements. In React Native, use accessibilityLabel, accessibilityRole, and accessibilityState props; in iOS, set isAccessibilityElement and accessibilityTraits; in Flutter, use Semantics widgets. Testing should include using the app with a screen reader enabled, running automated accessibility audits (Accessibility Inspector on iOS, Accessibility Scanner on Android), and including users with disabilities in beta testing.",
    category: "Mobile UI/UX",
    difficulty: "MEDIUM" as const,
    tags: ["accessibility", "a11y", "screen-reader", "mobile-ui", "wcag"],
  },
  {
    questionText: "What is a bottom sheet in mobile UI, and when should you use it versus other patterns?",
    idealAnswer: "A bottom sheet is a UI surface that slides up from the bottom of the screen, anchored to the bottom edge, used to present supplementary content, actions, or focused tasks without leaving the current context. There are two types: modal bottom sheets that overlay the screen with a dimmed background (requiring dismissal before interacting with the underlying content) and persistent bottom sheets that coexist with the main content and can be expanded or collapsed. Bottom sheets are preferred over full-screen modals when the content is secondary to the main task, over menus when you need more space for content or actions, and over dialogs when the content is scrollable or interactive (like a filter panel or sharing options). They leverage the natural thumb-reach zone on large phones, making them ergonomically superior to top-positioned elements, and are especially useful for actions triggered from lists (like options for a specific item). Best practices include making them dismissable by swiping down or tapping the overlay, providing a clear visual handle/grabber at the top, and ensuring the content is usable at different sheet heights through multiple snap points (collapsed, half-expanded, fully expanded).",
    category: "Mobile UI/UX",
    difficulty: "EASY" as const,
    tags: ["bottom-sheet", "ui-patterns", "mobile-ui", "interaction-design"],
  },
  {
    questionText: "How do you implement smooth animations in a mobile app, and what principles should guide animation design?",
    idealAnswer: "Smooth animations in mobile apps require running at 60fps (16.67ms per frame) or higher on modern devices, which means animation logic should be offloaded from the JavaScript thread to the native/GPU thread whenever possible. In React Native, use the Animated API with useNativeDriver: true to run animations on the native thread, or use Reanimated 2/3 for more complex gesture-driven animations that run entirely on the UI thread via worklets. In iOS, Core Animation and UIViewPropertyAnimator handle hardware-accelerated animations, while SwiftUI provides implicit (.animation modifier) and explicit (withAnimation) animation APIs. Flutter's animation system includes implicit animations (AnimatedContainer, AnimatedOpacity) for simple transitions and explicit animations (AnimationController, Tween) for complex choreography. Key design principles include: animations should be purposeful (guiding attention, showing relationships, providing feedback) not decorative, duration should be 200-500ms for most transitions (shorter feels snappy, longer feels sluggish), use natural easing curves (ease-in-out for movement, ease-out for entrance) rather than linear motion, and respect the user's reduced motion preferences (accessible motion settings) by simplifying or disabling animations when the system setting is enabled.",
    category: "Mobile UI/UX",
    difficulty: "HARD" as const,
    tags: ["animations", "performance", "mobile-ui", "60fps", "user-experience"],
  },
  {
    questionText: "What is the MVVM (Model-View-ViewModel) architecture pattern, and how is it applied in mobile development?",
    idealAnswer: "MVVM separates a mobile application into three layers: the Model (business logic and data, including API calls, database access, and data transformation), the View (UI components that display data and capture user input), and the ViewModel (an intermediary that exposes data from the Model in a format the View can easily consume, handling presentation logic and state). The ViewModel holds observable state (LiveData/StateFlow in Android, @Published in SwiftUI, useState/Zustand in React Native) that the View binds to, meaning UI updates automatically when the ViewModel's state changes without the ViewModel knowing anything about the View. This separation enables excellent testability because ViewModels can be unit tested without any UI framework dependencies, and Views can be tested independently by providing mock ViewModels. In Android, ViewModel is a Jetpack component that survives configuration changes; in iOS/SwiftUI, ObservableObject serves a similar role; in React Native, custom hooks or store modules act as ViewModels. The key benefit for mobile development is that the same ViewModel logic can potentially be shared across platforms (using Kotlin Multiplatform, for example) while only the View layer is platform-specific.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["mvvm", "architecture", "design-patterns", "mobile-architecture", "testability"],
  },
  {
    questionText: "How do you handle forms and user input validation in a mobile application?",
    idealAnswer: "Form handling in mobile apps involves managing input state, validating data, displaying errors, and handling submission, with the approach varying by framework but following common patterns. In React Native, libraries like React Hook Form or Formik manage form state and validation with minimal re-renders, supporting schema validation through Yup or Zod for declarative rules. Real-time validation should provide immediate feedback as users type (debounced for performance) or on field blur, while form-level validation runs on submission to catch cross-field rules. Error messages should appear directly below the relevant input field, use clear language explaining how to fix the issue (not just 'invalid input'), and be announced to screen readers via accessibility live regions. Mobile-specific considerations include: configuring the keyboard type (numeric, email, phone) via the keyboardType prop, setting return key behavior to advance to the next field using ref-based focus management, handling keyboard avoidance so forms remain visible above the keyboard (KeyboardAvoidingView or KeyboardAwareScrollView), and auto-filling from the device keychain where appropriate. Submission should disable the button and show a loading state to prevent double submissions, handle network errors gracefully, and provide clear success feedback.",
    category: "Mobile UI/UX",
    difficulty: "MEDIUM" as const,
    tags: ["forms", "validation", "user-input", "mobile-ui", "error-handling"],
  },
  {
    questionText: "What are gesture handlers in mobile development, and how do you implement complex touch interactions?",
    idealAnswer: "Gesture handlers are systems that interpret raw touch events into meaningful interactions like taps, swipes, pinches, rotations, long presses, and custom drag behaviors, with each mobile platform providing native gesture recognition systems. In React Native, react-native-gesture-handler replaces the built-in gesture system with native gesture recognizers (running on the UI thread) that support simultaneous recognition, gesture composition, and proper interaction with scrollable containers. Pan gestures track finger movement for drag-and-drop interfaces, pinch gestures enable zoom functionality, and long press gestures trigger contextual menus; these can be combined (like simultaneous pan and pinch for a map interface) or made exclusive (like distinguishing a tap from a long press). In iOS, UIGestureRecognizer subclasses handle touch interpretation, with delegate methods controlling how gestures interact with each other and the responder chain. Flutter uses GestureDetector widget wrapping with support for all standard gestures and RawGestureDetector for custom recognition. Complex interactions like swipeable list items, draggable cards, or pull-to-refresh require combining gesture handlers with animated values, running animations on the native thread for smooth 60fps performance, and properly handling gesture state transitions (began, changed, ended, cancelled).",
    category: "Mobile UI/UX",
    difficulty: "HARD" as const,
    tags: ["gestures", "touch-interactions", "mobile-ui", "animations", "user-experience"],
  },
  {
    questionText: "What is a design system, and why is it important for mobile app development?",
    idealAnswer: "A design system is a comprehensive collection of reusable UI components, design tokens (colors, typography, spacing), patterns, and guidelines that ensure visual and functional consistency across an application and its platforms. It typically includes a component library (buttons, inputs, cards, modals implemented in code), a token system (defining brand colors, font scales, border radii, shadow values as platform-agnostic variables), and documentation describing when and how to use each element. For mobile development, a design system is critical because it reduces design-to-development friction, ensures brand consistency across iOS and Android, accelerates development by providing pre-built, tested components, and makes maintaining accessibility standards systematic rather than ad-hoc. Implementation involves creating a shared component library (like a components/ directory in React Native, a Swift Package for iOS, or a design module in Android) with themed variants, dark mode support, and built-in accessibility properties. Tools like Storybook (for React Native), Xcode Previews (for SwiftUI), and Widget previews (for Flutter) enable isolated component development and visual testing, while design tools like Figma maintain parity between design mockups and coded components.",
    category: "Mobile UI/UX",
    difficulty: "EASY" as const,
    tags: ["design-system", "ui-components", "consistency", "mobile-ui", "tokens"],
  },
  {
    questionText: "How do you implement dark mode in a mobile application?",
    idealAnswer: "Implementing dark mode involves creating a dual-theme system that responds to the device's appearance setting, defining separate color palettes for light and dark modes, and ensuring all UI elements adapt correctly. The approach varies by platform: in React Native, you detect the system preference using useColorScheme() and manage theme state through a context provider that wraps the app, passing themed styles to components; in iOS/SwiftUI, you use semantic colors from the asset catalog that automatically adapt, or define Color sets with Any/Dark/Light variants; in Flutter, you define ThemeData objects for both modes and pass them to MaterialApp's theme and darkTheme properties. Color design for dark mode is not simply inverting colors; dark mode should use dark gray surfaces (not pure black, which creates too much contrast with white text), ensure text meets WCAG contrast ratios against dark backgrounds, adjust image and illustration brightness, and reduce the saturation of accent colors so they don't vibrate visually against dark surfaces. Persistent user preference (overriding system default) should be stored locally, elevation in dark mode should use lighter surface colors rather than shadows (since shadows are invisible on dark backgrounds), and all states (disabled, selected, error) need separate dark mode consideration.",
    category: "Mobile UI/UX",
    difficulty: "MEDIUM" as const,
    tags: ["dark-mode", "theming", "mobile-ui", "color-system", "user-preferences"],
  },

  // ==================== App Store Deployment (10 questions) ====================
  {
    questionText: "What are the key steps to publish an app on the Apple App Store?",
    idealAnswer: "Publishing to the Apple App Store involves several steps: first, enroll in the Apple Developer Program ($99/year), create an App ID and provisioning profiles in the Apple Developer portal, and configure your app's bundle identifier, version, and build number in Xcode. Next, prepare App Store Connect by creating a new app record, filling in metadata (app name, description, keywords, categories, screenshots for each required device size, and app preview videos), setting pricing and availability, and completing the App Review Information section. Build and archive your app in Xcode using a distribution provisioning profile, then upload the archive to App Store Connect via Xcode's Organizer or Transporter. Before submission, ensure compliance with the App Store Review Guidelines covering content, design, functionality, privacy (including an App Privacy nutrition label), and legal requirements. Submit the build for review, which typically takes 24-48 hours; address any rejections by reading the detailed feedback, making corrections, and resubmitting. Once approved, you can release immediately, schedule a specific date, or manually release when ready.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["app-store", "ios", "deployment", "publishing", "apple"],
  },
  {
    questionText: "What are the key steps to publish an app on the Google Play Store?",
    idealAnswer: "Publishing to the Google Play Store starts with creating a Google Play Developer account (one-time $25 fee), then setting up your app in the Google Play Console by providing the app name, default language, and app or game category. You prepare the store listing with a description, screenshots (phone, tablet, Chromebook), feature graphic, app icon, privacy policy URL, and content rating questionnaire. Build a release-ready APK or Android App Bundle (AAB, now required and preferred because it enables dynamic delivery and smaller downloads), sign it with your upload key (Google manages the app signing key through Play App Signing), and upload it to a release track. Google Play offers testing tracks: internal testing (up to 100 testers, no review), closed testing (invited users, optional review), open testing (public, reviewed), and production. Before production release, complete the Data Safety section declaring what data you collect, use, and share, select appropriate content ratings, and configure pricing and distribution countries. Review typically takes hours to a few days; once approved, you can manage staged rollouts (releasing to a percentage of users) to monitor crash rates and feedback before full deployment.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["google-play", "android", "deployment", "publishing", "app-bundle"],
  },
  {
    questionText: "What is code signing, and why is it required for mobile app distribution?",
    idealAnswer: "Code signing is a cryptographic process that uses digital certificates and provisioning profiles to verify the identity of the app developer and ensure the app's code hasn't been tampered with since it was signed. On iOS, Apple issues signing certificates tied to your developer account, and provisioning profiles link the certificate to specific app IDs and device UUIDs (for development) or distribution methods (App Store, Ad Hoc, Enterprise); Xcode manages this through automatic signing or manual profile selection. On Android, apps are signed with a keystore containing a private key; Google Play App Signing separates the upload key (which you hold) from the app signing key (held by Google), so if your upload key is compromised, Google can rotate it without affecting users. Code signing protects users by guaranteeing that the app comes from a verified source and hasn't been modified by malicious actors during distribution. Losing your signing key or certificate can be catastrophic: on iOS, your provisioning profiles become invalid; on Android before Play App Signing, you would be unable to publish updates to the same app listing. Best practices include storing signing credentials securely (never in version control), using CI/CD secret management for automated builds, and enabling Play App Signing on Android.",
    category: "Mobile Security",
    difficulty: "HARD" as const,
    tags: ["code-signing", "certificates", "security", "deployment", "app-store"],
  },
  {
    questionText: "What is CI/CD for mobile apps, and how do you set up automated build and deployment pipelines?",
    idealAnswer: "CI/CD (Continuous Integration/Continuous Deployment) for mobile apps automates the process of building, testing, signing, and distributing app binaries whenever code changes are pushed, reducing manual errors and accelerating release cycles. A typical pipeline includes: running linters and unit tests on every pull request (CI), building debug/release binaries for both platforms, running UI/integration tests on device farms, and deploying to beta distribution (CD) or app stores. Popular mobile CI/CD platforms include Fastlane (open-source automation for build, test, and release), GitHub Actions, Bitrise, CircleCI, and Codemagic (Flutter-focused). A practical setup involves: configuring a CI service to trigger on push/PR, using Fastlane lanes for platform-specific build steps (match for iOS code signing, gradle for Android builds), running tests with result reporting, uploading builds to Firebase App Distribution or TestFlight for beta testing, and promoting to production app stores after approval. Key challenges specific to mobile include: managing iOS code signing in CI (solved by Fastlane match or cloud signing), maintaining build environments for both platforms, managing multiple build flavors/schemes, and handling the asynchronous nature of app store review processes.",
    category: "Mobile Architecture",
    difficulty: "HARD" as const,
    tags: ["ci-cd", "automation", "fastlane", "deployment", "devops"],
  },
  {
    questionText: "What is an Android App Bundle (AAB), and how does it differ from an APK?",
    idealAnswer: "An Android App Bundle (AAB) is the modern publishing format for Android apps that contains all compiled code and resources but defers APK generation and signing to Google Play, whereas an APK (Android Package Kit) is a single, self-contained installation file. When you upload an AAB, Google Play uses Dynamic Delivery to generate optimized APKs for each device configuration, including only the resources (screen density images, CPU architecture libraries, language files) needed for that specific device. This typically results in 15-30% smaller downloads compared to a universal APK that must include all configurations. AAB also enables on-demand feature delivery through Play Feature Delivery, where parts of the app are downloaded only when the user needs them (like an AR camera module or premium content), and instant app experiences where users can try features without full installation. Since August 2021, Google Play requires new apps to use AAB format. For local testing of AABs, you use bundletool to generate device-specific APKs and install them, and for distribution outside Google Play (like enterprise or direct distribution), you still need to generate APKs.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["android", "app-bundle", "apk", "google-play", "deployment"],
  },
  {
    questionText: "What is app versioning, and what strategies should mobile developers follow?",
    idealAnswer: "App versioning uses two key identifiers: a human-readable version string (like 2.1.0) displayed to users in app stores, and a build number (integer) used internally to uniquely identify each build submitted to app stores. Semantic versioning (MAJOR.MINOR.PATCH) is the standard approach where MAJOR increments for breaking changes or major redesigns, MINOR for new features that are backward-compatible, and PATCH for bug fixes and small improvements. On iOS, CFBundleShortVersionString is the marketing version and CFBundleVersion is the build number; on Android, versionName is the display version and versionCode is an integer that must strictly increase with each Play Store upload. The build number should increment with every build submitted to app stores (even if the marketing version stays the same), and many teams use CI build numbers or timestamps to automate this. For cross-platform apps, keep the marketing version synchronized across platforms while build numbers can differ. Version codes/numbers are critical for the update mechanism: app stores use them to determine if an update is available, and the app can use them to trigger data migrations between versions or show 'what's new' screens after updates.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["versioning", "semantic-versioning", "deployment", "app-store", "release-management"],
  },
  {
    questionText: "What are common reasons for app store rejection, and how do you avoid them?",
    idealAnswer: "App store rejections commonly fall into several categories that can be avoided with proper preparation. Performance issues include crashes, broken links, and incomplete features (all screens and functionality must work, even placeholder content is rejected); always thoroughly test on real devices before submission. Design violations include non-standard navigation patterns, using platform-inappropriate UI elements (like Android-style components on iOS), and poor adaptation to different screen sizes and notch/dynamic island areas. Privacy concerns are increasingly common: you must include a privacy policy URL, accurately declare data collection in App Privacy labels (iOS) and Data Safety sections (Android), request permissions at the time of use with clear purpose strings, and implement App Tracking Transparency on iOS. Content policy violations include inappropriate content, misleading descriptions or screenshots, and hidden functionality. iOS-specific rejections include apps that are too simple (mere website wrappers), apps that duplicate system functionality without significant additional value, and apps that use private APIs. To avoid rejection, review the latest Apple App Store Review Guidelines and Google Play Developer Policy Center before each submission, use Xcode's validation and Google Play's pre-launch report, and write detailed App Review notes explaining any non-obvious features.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["app-store", "rejection", "guidelines", "compliance", "publishing"],
  },
  {
    questionText: "What is over-the-air (OTA) updating for mobile apps, and what are its limitations?",
    idealAnswer: "Over-the-air updating allows pushing JavaScript bundle or asset updates to users' devices without going through the app store review and release process, enabling immediate bug fixes and feature rollouts. Microsoft's CodePush (now part of App Center, being replaced by Expo Updates ecosystem) and Expo Updates are the main solutions for React Native, while Shorebird provides OTA updates for Flutter by patching the compiled Dart code. OTA updates work by checking for new bundles at app startup or on a schedule, downloading the delta, and applying it on the next app restart or immediately. The key limitations are: only JavaScript/Dart code and assets can be updated, not native code changes (new native modules, SDK version changes, or native dependency updates still require store submissions). Apple's App Store guidelines allow OTA updates for interpreted code as long as the updates don't fundamentally change the app's purpose or create a store within a store, and Google Play has similar policies. Best practices include implementing rollback mechanisms for faulty updates, using staged rollouts to test updates with a subset of users first, maintaining multiple release channels (staging and production), and clearly versioning OTA updates separately from binary versions for debugging purposes.",
    category: "Mobile Architecture",
    difficulty: "HARD" as const,
    tags: ["ota-updates", "codepush", "deployment", "react-native", "flutter"],
  },
  {
    questionText: "How do you manage app store screenshots and metadata for a mobile app launch?",
    idealAnswer: "App store optimization (ASO) treats screenshots and metadata as critical marketing assets that directly impact download conversion rates. Screenshots must be provided for each required device size: Apple requires iPhone 6.7\", 6.5\", 5.5\" and optionally iPad sizes, while Google Play requires phone screenshots and recommends tablet and Chromebook. Best practices include using the first two screenshots to communicate the app's primary value proposition (these are visible without scrolling), including device frames and descriptive text overlays that highlight key features, showing real app UI rather than conceptual mockups, and localizing screenshots for major markets. Tools like Fastlane's snapshot (iOS) and screengrab (Android) can automate screenshot capture across devices and languages, and Figma/Sketch templates help create consistent framed screenshots. Metadata optimization involves choosing a keyword-rich title (30 chars on iOS, 50 on Android), writing a compelling subtitle (iOS) or short description (Android) that includes primary keywords, structuring the full description with key features bulleted at the top, and selecting the most accurate category. Update metadata regularly with each release to highlight new features, and use A/B testing on Google Play (Store Listing Experiments) to optimize conversion rates.",
    category: "Mobile Architecture",
    difficulty: "MEDIUM" as const,
    tags: ["aso", "app-store", "screenshots", "metadata", "marketing"],
  },
  {
    questionText: "What is TestFlight, and how do you use it for iOS beta testing?",
    idealAnswer: "TestFlight is Apple's official platform for distributing beta versions of iOS, iPadOS, tvOS, watchOS, and macOS apps to up to 10,000 external testers without App Store review requirements for internal testers. Internal testers are App Store Connect users on your team (up to 100), who can install builds immediately after upload without any review process, making this ideal for QA teams and stakeholders. External testers are invited via email or a public link, but the first build for external testing requires a brief Beta App Review by Apple (usually faster than full App Store review). You upload builds to App Store Connect through Xcode's archive and upload workflow or via CI/CD using tools like Fastlane's pilot, then assign builds to tester groups and add release notes describing what to test. TestFlight provides built-in feedback collection: testers can submit screenshots and written feedback directly from the TestFlight app, and crash reports from beta builds appear in App Store Connect and Xcode's Organizer. Builds expire after 90 days, and you can manage multiple build groups with different builds to test different features simultaneously. TestFlight automatically sends notifications to testers when new builds are available and tracks installation and session metrics to gauge tester engagement.",
    category: "Mobile Architecture",
    difficulty: "EASY" as const,
    tags: ["testflight", "ios", "beta-testing", "deployment", "apple"],
  },

  // ==================== Mobile Performance (10 questions) ====================
  {
    questionText: "What are the key performance metrics to monitor in a mobile application?",
    idealAnswer: "Key performance metrics for mobile apps span several categories: startup time (cold start from terminated state, warm start from background, and hot start from memory), which should be under 2 seconds for cold start; frame rendering (targeting consistent 60fps with frame drop rate below 1%); memory usage (peak memory, growth over time, and proximity to the OS kill threshold); network performance (API response times, payload sizes, retry rates, and offline handling); and battery consumption (CPU wake time, background activity, and location usage). User-experience metrics include Time to Interactive (when the app is usable after launch), gesture response latency (time from touch to visual response, ideally under 100ms), and scroll performance (measured by dropped frames during list scrolling). Tools for monitoring include Firebase Performance Monitoring for production metrics across your user base, Xcode Instruments for iOS profiling (Time Profiler, Allocations, Energy Log), Android Studio Profiler for CPU, memory, and network analysis, and Flipper/React Native Performance Monitor for React Native apps. Setting performance budgets (maximum acceptable values for each metric) and monitoring them in CI/CD prevents performance regressions from reaching production.",
    category: "Mobile Performance",
    difficulty: "MEDIUM" as const,
    tags: ["performance", "metrics", "monitoring", "mobile-optimization", "profiling"],
  },
  {
    questionText: "How do you reduce the startup time of a mobile application?",
    idealAnswer: "Reducing mobile app startup time requires optimizing each phase: the pre-main phase (before your code executes), the initialization phase (setting up frameworks and dependencies), and the first-frame phase (rendering the initial UI). For the pre-main phase, reduce the number of dynamic libraries and frameworks loaded at launch (merge or statically link them), minimize auto-linked pods/dependencies, and on iOS use dyld optimization hints. During initialization, defer non-essential setup using lazy initialization: don't initialize analytics, crash reporting, or feature flags synchronously at launch; instead, queue them for after the first frame renders. For first-frame rendering, use a lightweight splash/launch screen that appears instantly, minimize the complexity of the first rendered view, and defer data fetching (show skeleton screens or cached data first). In React Native, enable Hermes for faster JS parsing, use inline requires to lazy-load modules, and minimize the JS bundle size through code splitting. On Android, enable baseline profiles (compile ahead-of-time the code paths used during startup) and use the App Startup library for ordering initializer dependencies. Profile startup systematically using Xcode's App Launch instrument or Android Studio's startup profiler to identify the actual bottlenecks.",
    category: "Mobile Performance",
    difficulty: "HARD" as const,
    tags: ["performance", "startup-time", "optimization", "lazy-loading", "profiling"],
  },
  {
    questionText: "What causes memory leaks in mobile apps, and how do you detect and fix them?",
    idealAnswer: "Memory leaks in mobile apps occur when objects are retained in memory longer than needed, typically due to strong reference cycles (retain cycles in iOS), uncanceled subscriptions or listeners, static/global references holding onto large objects, or closures capturing strong references to objects that should be deallocated. In iOS, retain cycles are the most common cause: two objects holding strong references to each other, or a closure capturing self strongly; these are fixed using weak or unowned references. In Android, common leaks include holding Activity references in long-lived objects, unregistered BroadcastReceivers, uncanceled AsyncTasks or coroutines, and inner classes that implicitly reference their outer class. Detection tools include Xcode's Memory Graph Debugger (shows the object graph and highlights leaked objects), Instruments' Leaks and Allocations tools, Android Studio's Memory Profiler (tracks allocations and detects leaks), and LeakCanary (automatic leak detection library for Android). In React Native, leaks often occur from uncleared setInterval/setTimeout in useEffect without cleanup functions, event emitter subscriptions not removed on unmount, and storing large data in global state. Regular memory profiling during development, automated leak detection in CI, and code reviews focused on lifecycle management are essential preventive measures.",
    category: "Mobile Performance",
    difficulty: "HARD" as const,
    tags: ["memory-leaks", "performance", "debugging", "profiling", "mobile-optimization"],
  },
  {
    questionText: "How do you optimize images and assets for mobile app performance?",
    idealAnswer: "Image optimization is critical because images are typically the largest assets in a mobile app, directly impacting download size, memory usage, and rendering performance. Use appropriate formats: WebP provides 25-35% smaller file sizes than PNG/JPEG with comparable quality (supported on both platforms), SVG for icons and simple graphics that scale without quality loss, and HEIF/HEIC for photos on iOS. Provide images at the correct resolution for each screen density (@1x, @2x, @3x on iOS; mdpi through xxxhdpi on Android) or use vector formats to avoid shipping unnecessary pixels. Implement lazy loading for images not visible on screen (libraries like FastImage in React Native, Coil/Glide in Android, SDWebImage/Kingfisher in iOS handle this with disk and memory caching). Compress images during the build process using tools like imagemin, TinyPNG API, or platform-specific asset catalogs that optimize automatically. For remote images, use CDNs with image transformation capabilities (Cloudinary, Imgix) to request images at the exact size needed rather than downloading full-resolution images and resizing on device. Consider progressive JPEG loading for large images and blur-hash placeholders for a better perceived loading experience.",
    category: "Mobile Performance",
    difficulty: "MEDIUM" as const,
    tags: ["images", "assets", "optimization", "performance", "mobile-optimization"],
  },
  {
    questionText: "What is the difference between the main thread and background threads in mobile development, and why does it matter?",
    idealAnswer: "The main thread (also called the UI thread) is responsible for rendering the user interface, processing user input events, and running animation frames, and it must complete each frame's work within approximately 16.67ms (for 60fps) to maintain a smooth experience. Background threads (or worker threads, dispatch queues, isolates) handle computationally expensive or I/O-bound operations like network requests, database queries, image processing, and data parsing without blocking the UI. If heavy work runs on the main thread, the app becomes unresponsive: animations stutter (dropped frames), touch events queue up instead of being processed immediately, and the OS may terminate the app with an ANR (Application Not Responding) on Android or a watchdog timeout on iOS. In iOS, Grand Central Dispatch (GCD) and OperationQueue manage background work; in Android, coroutines with Dispatchers.IO handle this; in React Native, the JS thread is separate from the main thread but still single-threaded, so heavy computation blocks JS-driven UI updates; in Flutter, Isolates provide true parallel execution since Dart is single-threaded per isolate. The golden rule is: only access and update UI elements from the main thread, and never perform blocking operations (network calls, file I/O, heavy computation) on it.",
    category: "Mobile Performance",
    difficulty: "EASY" as const,
    tags: ["threads", "main-thread", "background-processing", "performance", "concurrency"],
  },
  {
    questionText: "How do you implement efficient caching strategies in a mobile application?",
    idealAnswer: "Effective caching in mobile apps operates at multiple levels: in-memory caches for frequently accessed data during the current session, disk caches for persisting data across launches, and HTTP caching for network responses. In-memory caching uses data structures like LRU (Least Recently Used) caches with size limits to store parsed API responses, computed values, or decoded images, providing instant access without I/O overhead. Disk caching stores serialized data (using JSON, Protocol Buffers, or platform-native formats) in the app's cache directory, which the OS can reclaim under storage pressure. HTTP caching leverages Cache-Control headers, ETags, and Last-Modified headers to avoid redundant network requests; libraries like OkHttp (Android), URLCache (iOS), and Axios (React Native) handle this automatically with proper server configuration. Cache invalidation strategies include time-based expiration (TTL), version-based invalidation (clearing cache on app update), event-based invalidation (clearing when the user performs an action), and stale-while-revalidate (show cached data immediately while fetching fresh data in the background). The optimal strategy depends on data freshness requirements: user profiles can be cached for minutes, static content like icons for days, and configuration data should use a stale-while-revalidate approach for the best user experience.",
    category: "Mobile Performance",
    difficulty: "MEDIUM" as const,
    tags: ["caching", "performance", "networking", "optimization", "mobile-architecture"],
  },
  {
    questionText: "How do you reduce the size of a mobile app binary?",
    idealAnswer: "Reducing app binary size improves download conversion rates (every 6MB increase reduces installs by 1% according to Google) and is critical for users on limited storage or slow networks. On Android, use Android App Bundles for Dynamic Delivery (serving only device-specific resources), enable R8/ProGuard for code shrinking and obfuscation, use resConfigs to include only needed language resources, and strip debug symbols from native libraries. On iOS, enable Bitcode (deprecated in Xcode 14 but App Thinning still provides device-specific delivery), use asset catalogs with app slicing, and enable Link-Time Optimization (LTO) for smaller compiled code. Cross-platform strategies include: auditing and removing unused dependencies (use bundle analyzers to visualize what's consuming space), replacing large libraries with smaller alternatives (like using date-fns instead of moment.js), compressing images and using vector formats where possible, and lazy-loading features through dynamic modules. For React Native, enable Hermes (smaller bytecode bundles), use Metro's tree-shaking, and review the bundle with source-map-explorer to identify large modules. Regularly measure your app size as part of CI/CD with alerts when size exceeds budgets, and use App Store Connect's App Size report or APK Analyzer in Android Studio to understand the composition.",
    category: "Mobile Performance",
    difficulty: "HARD" as const,
    tags: ["app-size", "optimization", "binary-size", "performance", "deployment"],
  },
  {
    questionText: "What is lazy loading in mobile development, and how does it improve performance?",
    idealAnswer: "Lazy loading is a design pattern that defers the initialization of resources, modules, or data until they are actually needed, rather than loading everything at app startup or screen mount. In the context of mobile screens, lazy loading means only rendering components that are visible in the viewport (as FlatList and RecyclerView do for list items), fetching data for a screen only when the user navigates to it, and importing heavy modules only when the feature is accessed. For images, lazy loading means downloading and decoding images only as they scroll into view, displaying placeholders until the actual image is ready, which significantly reduces initial memory usage and network bandwidth. In React Native, React.lazy and dynamic import() enable code-splitting where feature modules are loaded on demand; in Flutter, deferred loading with deferred as keyword achieves similar results; and in native Android, Play Feature Delivery allows downloading entire feature modules on demand. The benefits include faster app startup (less code parsed and executed initially), lower memory footprint (unused features don't consume memory), and reduced network usage (data fetched only when needed). The tradeoff is that lazily loaded content may have a slight delay on first access, which can be mitigated with predictive prefetching and skeleton screens.",
    category: "Mobile Performance",
    difficulty: "EASY" as const,
    tags: ["lazy-loading", "performance", "optimization", "code-splitting", "mobile"],
  },
  {
    questionText: "How do you profile and debug performance issues in a React Native application?",
    idealAnswer: "React Native performance profiling involves examining both the JavaScript thread and the native UI thread to identify bottlenecks. The React Native Performance Monitor (accessible through the dev menu) shows real-time JS and UI frame rates, highlighting when either thread drops below 60fps. Flipper is the primary debugging tool, providing a Performance plugin that shows frame timing, a React DevTools plugin for component profiling (identifying unnecessary re-renders), and network and database inspection. For JavaScript performance, use React Profiler (in React DevTools) to identify components that re-render frequently or take long to render, and Chrome DevTools' Performance tab when running in debug mode to trace CPU time. For native performance, use Xcode Instruments (Time Profiler, Core Animation) on iOS and Android Studio Profiler (CPU, Memory, Energy) on Android to profile the native side independently. Common performance issues include: unnecessary re-renders (solved with React.memo, useMemo, useCallback), running animations on the JS thread instead of native (solved with Reanimated or useNativeDriver), excessive bridge traffic (solved by batching operations or using the new architecture), and large list rendering (solved with FlashList or properly configured FlatList). Systrace on Android provides detailed per-frame analysis showing exactly which operations took too long.",
    category: "Mobile Performance",
    difficulty: "HARD" as const,
    tags: ["react-native", "profiling", "debugging", "performance", "flipper", "instruments"],
  },
  {
    questionText: "How do you optimize network requests in a mobile application?",
    idealAnswer: "Network optimization in mobile apps is critical because mobile networks have higher latency, lower bandwidth, and less reliability than desktop connections. Minimize the number of requests by batching related API calls (GraphQL naturally supports this), combining multiple resources into single endpoints, and implementing pagination (cursor-based for real-time data, offset-based for static data) to avoid loading entire datasets. Reduce payload sizes by requesting only needed fields (field selection in REST or GraphQL), compressing responses with gzip/brotli, using efficient serialization formats (Protocol Buffers, MessagePack) instead of verbose JSON for high-frequency endpoints, and paginating large lists. Implement intelligent retry logic with exponential backoff for failed requests, and use request deduplication to prevent duplicate in-flight requests for the same resource. Cache responses at multiple levels: HTTP cache headers for automatic caching, application-level cache for parsed data, and optimistic updates that immediately reflect user actions in the UI while syncing in the background. Monitor network performance in production using Firebase Performance Monitoring or custom metrics to track response times, error rates, and payload sizes across different network conditions and geographic regions.",
    category: "Mobile Performance",
    difficulty: "MEDIUM" as const,
    tags: ["networking", "performance", "optimization", "api", "caching"],
  },
];
